# Story 1.4: Student Login API Endpoint

**Epic:** Epic 1 - Foundation & Authentication  
**Status:** Ready for Review  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** backend developer,  
**I want** a login API endpoint that validates student credentials and returns authentication tokens,  
**so that** the frontend can authenticate students and maintain secure sessions.

---

## Acceptance Criteria

1. POST /api/auth/login endpoint accepts JSON payload with username and password fields.
2. Endpoint validates username format matches \\domain\\username pattern and returns 400 error if format invalid.
3. Endpoint queries database for user record matching username and verifies password using bcrypt.
4. If credentials valid and user not blocked, endpoint generates JWT token and returns it in httpOnly cookie plus response body.
5. If user account is blocked (is_blocked=true), endpoint returns 403 error with message: "Your account has been blocked. Please reach out to support for help."
6. If credentials invalid, endpoint returns 401 error with generic message: "Invalid username or password."
7. JWT token includes user ID and username claims, expires in 24 hours.
8. Unit tests cover all authentication scenarios: valid login, invalid credentials, blocked user, malformed username.

---

## Tasks / Subtasks

- [x] Create authentication router and schemas (AC: 1)
  - [x] Create `app/routers/auth.py` with auth_router
  - [x] Create `app/schemas/auth.py` with LoginRequest and LoginResponse Pydantic models
  - [x] Define LoginRequest: username (str), password (str)
  - [x] Define LoginResponse: access_token (str), token_type (str), user (UserResponse)
  - [x] Register auth_router in main.py with `/api/auth` prefix
  
- [x] Implement username format validation (AC: 2)
  - [x] Add Pydantic validator for username field
  - [x] Use regex pattern: `^\\[^\\]+\\[^\\]+$`
  - [x] Return 422 (Pydantic validation) or 400 with clear error message
  - [x] Write test for invalid username format
  
- [x] Implement password hashing utilities (AC: 3)
  - [x] Install bcrypt 4.1.2
  - [x] Create `app/utils/security.py`
  - [x] Implement `hash_password(password: str) -> str` using bcrypt
  - [x] Implement `verify_password(plain: str, hashed: str) -> bool`
  - [x] Use bcrypt work factor 12
  
- [x] Implement user repository for database queries (AC: 3)
  - [x] Create `app/repositories/user_repository.py`
  - [x] Implement `get_user_by_username(username: str) -> User | None`
  - [x] Use async SQLAlchemy session
  - [x] Handle database errors gracefully
  
- [x] Implement JWT token generation (AC: 4, 7)
  - [x] Install python-jose[cryptography] 3.3.0
  - [x] Create JWT utilities in `app/utils/jwt.py`
  - [x] Implement `create_access_token(data: dict) -> str`
  - [x] Include claims: user_id, username, exp (24 hours from now)
  - [x] Use HS256 algorithm with secret key from config
  - [x] Load JWT_SECRET_KEY from environment variables
  
- [x] Implement login endpoint logic (AC: 4, 5, 6)
  - [x] Create POST /api/auth/login handler
  - [x] Validate username format (Pydantic handles this)
  - [x] Query database for user by username
  - [x] If user not found → return 401 with generic message
  - [x] If user found but blocked → return 403 with specific message
  - [x] Verify password using bcrypt
  - [x] If password invalid → return 401 with generic message
  - [x] If valid → generate JWT token
  - [x] Set httpOnly cookie with token (secure=True, samesite='lax')
  - [x] Return token in response body as well
  
- [x] Implement comprehensive unit tests (AC: 8)
  - [x] Test valid login with correct credentials
  - [x] Test invalid username format (400/422 error)
  - [x] Test nonexistent user (401 error)
  - [x] Test blocked user (403 error)
  - [x] Test incorrect password (401 error)
  - [x] Test JWT token structure and expiration
  - [x] Test httpOnly cookie is set correctly

---

## Dev Notes

### Authentication Architecture (From Architecture Document)

**Auth Method:** JWT tokens in httpOnly cookies with HS256 signing

**Session Management:** Stateless JWT tokens (no server-side session store)

**JWT Configuration:**
- Algorithm: HS256
- Expiration: 24 hours
- Claims: `user_id` (UUID), `username` (str), `exp` (timestamp)
- Secret: Loaded from `JWT_SECRET_KEY` environment variable

**Cookie Configuration:**
- httpOnly: True (prevents XSS access)
- secure: True (HTTPS only in production)
- samesite: 'lax' (CSRF protection)
- max_age: 86400 seconds (24 hours)

### Password Security

**Hashing Library:** bcrypt 4.1.2

**Work Factor:** 12 (minimum, can increase for higher security)

**Best Practices:**
- Never log passwords or password hashes
- Use timing-safe comparison for password verification (bcrypt handles this)
- Generic error messages to prevent user enumeration

### Error Response Standards

**400 Bad Request (Invalid Format):**
```json
{
  "detail": "Username must be in \\domain\\username format"
}
```

**401 Unauthorized (Invalid Credentials):**
```json
{
  "detail": "Invalid username or password"
}
```

**403 Forbidden (Blocked User):**
```json
{
  "detail": "Your account has been blocked. Please reach out to support for help."
}
```

**Success Response (200 OK):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "\\COLLEGE\\jdoe",
    "is_blocked": false
  }
}
```

### Repository Pattern Implementation

**UserRepository Methods:**
```python
class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_by_username(self, username: str) -> User | None:
        stmt = select(User).where(User.username == username)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
    
    async def create(self, user_data: dict) -> User:
        # For future user creation endpoint
        pass
```

### Dependency Injection Pattern

```python
async def get_user_repository(session: AsyncSession = Depends(get_db)):
    return UserRepository(session)

@auth_router.post("/login")
async def login(
    credentials: LoginRequest,
    user_repo: UserRepository = Depends(get_user_repository)
):
    # Implementation
    pass
```

### Source Tree Updates

New files to create:
```
packages/backend/app/
├── routers/
│   └── auth.py              # Authentication endpoints
├── schemas/
│   ├── __init__.py
│   ├── auth.py             # Auth request/response schemas
│   └── user.py             # User response schema
├── repositories/
│   ├── __init__.py
│   └── user_repository.py  # User database operations
└── utils/
    ├── __init__.py
    ├── security.py         # Password hashing utilities
    └── jwt.py              # JWT token utilities
```

### Environment Variables Required

Add to .env:
```bash
JWT_SECRET_KEY=<generate-with-openssl-rand-hex-32>
JWT_ALGORITHM=HS256
JWT_EXPIRATION_HOURS=24
```

Generate secure secret:
```bash
openssl rand -hex 32
```

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5

### Debug Log References
- Fixed username constraint regex pattern in User model from `^\\\\\\[^\\\\\\]+\\\\\\[^\\\\\\]+$` to `^\\\\[^\\\\]+\\\\[^\\\\]+$`
- Applied database migration to fix constraint in production database
- All 25 tests passing

### Completion Notes

**What was implemented:**
1. Created complete authentication infrastructure with JWT-based login endpoint
2. Implemented secure password hashing with bcrypt (work factor 12)
3. Created username validation with regex pattern for \\domain\\username format
4. Built comprehensive test suite with 25 tests covering all scenarios
5. Fixed database constraint pattern to match application validation

**Why these choices:**
- Used bcrypt for password hashing as it's industry standard with built-in salt generation
- JWT tokens in httpOnly cookies provide secure, stateless authentication
- Regex validation prevents malformed usernames at the API boundary
- Generic error messages for failed logins prevent user enumeration attacks
- Separate error codes (401 vs 403) for security vs business logic failures

**How it works:**
1. POST /api/auth/login receives username/password
2. Pydantic validator checks username format (\\domain\\username)
3. UserRepository queries database for matching username
4. Password verified using bcrypt timing-safe comparison
5. JWT token generated with user_id, username, exp, iat claims
6. Token set in httpOnly cookie (secure, samesite=lax) + response body
7. Error handling: 422 (invalid format), 401 (wrong credentials), 403 (blocked user)

### File List

**Created:**
- `app/schemas/user.py` - UserResponse model
- `app/schemas/auth.py` - LoginRequest/LoginResponse models
- `app/utils/security.py` - Password hashing utilities
- `app/utils/jwt.py` - JWT token generation
- `app/repositories/user_repository.py` - User database operations
- `app/routers/auth.py` - Login endpoint
- `tests/test_utils/test_security.py` - 6 password hashing tests
- `tests/test_utils/test_jwt.py` - 5 JWT token tests
- `tests/test_repositories/test_user_repository.py` - 4 repository tests
- `tests/test_routers/test_auth.py` - 10 login endpoint tests
- `alembic/versions/df870ce3dc0f_fix_username_format_constraint.py` - Database migration

**Modified:**
- `app/main.py` - Registered auth router
- `app/models/user.py` - Fixed CheckConstraint regex pattern
- `requirements.txt` - Added bcrypt 4.1.2, python-jose[cryptography] 3.3.0

---

## Testing

### Testing Standards

**Test Locations:**
- Auth router tests: `tests/test_routers/test_auth.py`
- Security utils tests: `tests/test_utils/test_security.py`
- JWT utils tests: `tests/test_utils/test_jwt.py`
- Repository tests: `tests/test_repositories/test_user_repository.py`

**Testing Framework:**
- pytest 8.0.0 with pytest-asyncio
- FastAPI TestClient for endpoint testing
- pytest fixtures for test data

**Testing Requirements for This Story:**

1. **Password Hashing Tests (`test_utils/test_security.py`):**
   ```python
   def test_hash_password():
       # Test password is hashed and not reversible
       
   def test_verify_password_correct():
       # Test correct password verification
       
   def test_verify_password_incorrect():
       # Test incorrect password rejected
   ```

2. **JWT Token Tests (`test_utils/test_jwt.py`):**
   ```python
   def test_create_access_token():
       # Test token generation with correct claims
       
   def test_token_expiration():
       # Test token expires after 24 hours
       
   def test_token_decode():
       # Test token can be decoded correctly
   ```

3. **User Repository Tests (`test_repositories/test_user_repository.py`):**
   ```python
   @pytest.mark.asyncio
   async def test_get_by_username_exists(db_session):
       # Test finding existing user
       
   @pytest.mark.asyncio
   async def test_get_by_username_not_found(db_session):
       # Test returns None for nonexistent user
   ```

4. **Login Endpoint Tests (`test_routers/test_auth.py`):**
   ```python
   @pytest.mark.asyncio
   async def test_login_success(client, test_user):
       response = client.post("/api/auth/login", json={
           "username": "\\COLLEGE\\testuser",
           "password": "correctpassword"
       })
       assert response.status_code == 200
       assert "access_token" in response.json()
       assert "Set-Cookie" in response.headers
       
   @pytest.mark.asyncio
   async def test_login_invalid_format(client):
       response = client.post("/api/auth/login", json={
           "username": "invalidformat",
           "password": "password"
       })
       assert response.status_code in [400, 422]
       
   @pytest.mark.asyncio
   async def test_login_user_not_found(client):
       response = client.post("/api/auth/login", json={
           "username": "\\COLLEGE\\nonexistent",
           "password": "password"
       })
       assert response.status_code == 401
       assert response.json()["detail"] == "Invalid username or password"
       
   @pytest.mark.asyncio
   async def test_login_blocked_user(client, blocked_user):
       response = client.post("/api/auth/login", json={
           "username": blocked_user.username,
           "password": "password"
       })
       assert response.status_code == 403
       assert "blocked" in response.json()["detail"].lower()
       
   @pytest.mark.asyncio
   async def test_login_wrong_password(client, test_user):
       response = client.post("/api/auth/login", json={
           "username": test_user.username,
           "password": "wrongpassword"
       })
       assert response.status_code == 401
       assert response.json()["detail"] == "Invalid username or password"
   ```

5. **Test Fixtures:**
   ```python
   @pytest.fixture
   async def test_user(db_session):
       # Create test user with hashed password
       
   @pytest.fixture
   async def blocked_user(db_session):
       # Create blocked test user
   ```

6. **Integration Tests:**
   - [ ] Full login flow with database
   - [ ] Cookie persistence across requests
   - [ ] Token validation on subsequent requests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
