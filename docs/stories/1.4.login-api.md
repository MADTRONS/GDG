# Story 1.4: Student Login API Endpoint

**Epic:** Epic 1 - Foundation & Authentication  
**Status:** Ready for Review  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** backend developer,  
**I want** a login API endpoint that validates student credentials and returns authentication tokens,  
**so that** the frontend can authenticate students and maintain secure sessions.

---

## Acceptance Criteria

1. POST /api/auth/login endpoint accepts JSON payload with username and password fields.
2. Endpoint validates username format matches \\domain\\username pattern and returns 400 error if format invalid.
3. Endpoint queries database for user record matching username and verifies password using bcrypt.
4. If credentials valid and user not blocked, endpoint generates JWT token and returns it in httpOnly cookie plus response body.
5. If user account is blocked (is_blocked=true), endpoint returns 403 error with message: "Your account has been blocked. Please reach out to support for help."
6. If credentials invalid, endpoint returns 401 error with generic message: "Invalid username or password."
7. JWT token includes user ID and username claims, expires in 24 hours.
8. Unit tests cover all authentication scenarios: valid login, invalid credentials, blocked user, malformed username.

---

## Tasks / Subtasks

- [x] Create authentication router and schemas (AC: 1)
  - [x] Create `app/routers/auth.py` with auth_router
  - [x] Create `app/schemas/auth.py` with LoginRequest and LoginResponse Pydantic models
  - [x] Define LoginRequest: username (str), password (str)
  - [x] Define LoginResponse: access_token (str), token_type (str), user (UserResponse)
  - [x] Register auth_router in main.py with `/api/auth` prefix
  
- [x] Implement username format validation (AC: 2)
  - [x] Add Pydantic validator for username field
  - [x] Use regex pattern: `^\\[^\\]+\\[^\\]+$`
  - [x] Return 422 (Pydantic validation) or 400 with clear error message
  - [x] Write test for invalid username format
  
- [x] Implement password hashing utilities (AC: 3)
  - [x] Install bcrypt 4.1.2
  - [x] Create `app/utils/security.py`
  - [x] Implement `hash_password(password: str) -> str` using bcrypt
  - [x] Implement `verify_password(plain: str, hashed: str) -> bool`
  - [x] Use bcrypt work factor 12
  
- [x] Implement user repository for database queries (AC: 3)
  - [x] Create `app/repositories/user_repository.py`
  - [x] Implement `get_user_by_username(username: str) -> User | None`
  - [x] Use async SQLAlchemy session
  - [x] Handle database errors gracefully
  
- [x] Implement JWT token generation (AC: 4, 7)
  - [x] Install python-jose[cryptography] 3.3.0
  - [x] Create JWT utilities in `app/utils/jwt.py`
  - [x] Implement `create_access_token(data: dict) -> str`
  - [x] Include claims: user_id, username, exp (24 hours from now)
  - [x] Use HS256 algorithm with secret key from config
  - [x] Load JWT_SECRET_KEY from environment variables
  
- [x] Implement login endpoint logic (AC: 4, 5, 6)
  - [x] Create POST /api/auth/login handler
  - [x] Validate username format (Pydantic handles this)
  - [x] Query database for user by username
  - [x] If user not found → return 401 with generic message
  - [x] If user found but blocked → return 403 with specific message
  - [x] Verify password using bcrypt
  - [x] If password invalid → return 401 with generic message
  - [x] If valid → generate JWT token
  - [x] Set httpOnly cookie with token (secure=True, samesite='lax')
  - [x] Return token in response body as well
  
- [x] Implement comprehensive unit tests (AC: 8)
  - [x] Test valid login with correct credentials
  - [x] Test invalid username format (400/422 error)
  - [x] Test nonexistent user (401 error)
  - [x] Test blocked user (403 error)
  - [x] Test incorrect password (401 error)
  - [x] Test JWT token structure and expiration
  - [x] Test httpOnly cookie is set correctly

---

## Dev Notes

### Authentication Architecture (From Architecture Document)

**Auth Method:** JWT tokens in httpOnly cookies with HS256 signing

**Session Management:** Stateless JWT tokens (no server-side session store)

**JWT Configuration:**
- Algorithm: HS256
- Expiration: 24 hours
- Claims: `user_id` (UUID), `username` (str), `exp` (timestamp)
- Secret: Loaded from `JWT_SECRET_KEY` environment variable

**Cookie Configuration:**
- httpOnly: True (prevents XSS access)
- secure: True (HTTPS only in production)
- samesite: 'lax' (CSRF protection)
- max_age: 86400 seconds (24 hours)

### Password Security

**Hashing Library:** bcrypt 4.1.2

**Work Factor:** 12 (minimum, can increase for higher security)

**Best Practices:**
- Never log passwords or password hashes
- Use timing-safe comparison for password verification (bcrypt handles this)
- Generic error messages to prevent user enumeration

### Error Response Standards

**400 Bad Request (Invalid Format):**
```json
{
  "detail": "Username must be in \\domain\\username format"
}
```

**401 Unauthorized (Invalid Credentials):**
```json
{
  "detail": "Invalid username or password"
}
```

**403 Forbidden (Blocked User):**
```json
{
  "detail": "Your account has been blocked. Please reach out to support for help."
}
```

**Success Response (200 OK):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "\\COLLEGE\\jdoe",
    "is_blocked": false
  }
}
```

### Repository Pattern Implementation

**UserRepository Methods:**
```python
class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_by_username(self, username: str) -> User | None:
        stmt = select(User).where(User.username == username)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
    
    async def create(self, user_data: dict) -> User:
        # For future user creation endpoint
        pass
```

### Dependency Injection Pattern

```python
async def get_user_repository(session: AsyncSession = Depends(get_db)):
    return UserRepository(session)

@auth_router.post("/login")
async def login(
    credentials: LoginRequest,
    user_repo: UserRepository = Depends(get_user_repository)
):
    # Implementation
    pass
```

### Source Tree Updates

New files to create:
```
packages/backend/app/
├── routers/
│   └── auth.py              # Authentication endpoints
├── schemas/
│   ├── __init__.py
│   ├── auth.py             # Auth request/response schemas
│   └── user.py             # User response schema
├── repositories/
│   ├── __init__.py
│   └── user_repository.py  # User database operations
└── utils/
    ├── __init__.py
    ├── security.py         # Password hashing utilities
    └── jwt.py              # JWT token utilities
```

### Environment Variables Required

Add to .env:
```bash
JWT_SECRET_KEY=<generate-with-openssl-rand-hex-32>
JWT_ALGORITHM=HS256
JWT_EXPIRATION_HOURS=24
```

Generate secure secret:
```bash
openssl rand -hex 32
```

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5

### Debug Log References
- Fixed username constraint regex pattern in User model from `^\\\\\\[^\\\\\\]+\\\\\\[^\\\\\\]+$` to `^\\\\[^\\\\]+\\\\[^\\\\]+$`
- Applied database migration to fix constraint in production database
- All 25 tests passing

### Completion Notes

**What was implemented:**
1. Created complete authentication infrastructure with JWT-based login endpoint
2. Implemented secure password hashing with bcrypt (work factor 12)
3. Created username validation with regex pattern for \\domain\\username format
4. Built comprehensive test suite with 25 tests covering all scenarios
5. Fixed database constraint pattern to match application validation

**Why these choices:**
- Used bcrypt for password hashing as it's industry standard with built-in salt generation
- JWT tokens in httpOnly cookies provide secure, stateless authentication
- Regex validation prevents malformed usernames at the API boundary
- Generic error messages for failed logins prevent user enumeration attacks
- Separate error codes (401 vs 403) for security vs business logic failures

**How it works:**
1. POST /api/auth/login receives username/password
2. Pydantic validator checks username format (\\domain\\username)
3. UserRepository queries database for matching username
4. Password verified using bcrypt timing-safe comparison
5. JWT token generated with user_id, username, exp, iat claims
6. Token set in httpOnly cookie (secure, samesite=lax) + response body
7. Error handling: 422 (invalid format), 401 (wrong credentials), 403 (blocked user)

### File List

**Created:**
- `app/schemas/user.py` - UserResponse model
- `app/schemas/auth.py` - LoginRequest/LoginResponse models
- `app/utils/security.py` - Password hashing utilities
- `app/utils/jwt.py` - JWT token generation
- `app/repositories/user_repository.py` - User database operations
- `app/routers/auth.py` - Login endpoint
- `tests/test_utils/test_security.py` - 6 password hashing tests
- `tests/test_utils/test_jwt.py` - 5 JWT token tests
- `tests/test_repositories/test_user_repository.py` - 4 repository tests
- `tests/test_routers/test_auth.py` - 10 login endpoint tests
- `alembic/versions/df870ce3dc0f_fix_username_format_constraint.py` - Database migration

**Modified:**
- `app/main.py` - Registered auth router
- `app/models/user.py` - Fixed CheckConstraint regex pattern
- `requirements.txt` - Added bcrypt 4.1.2, python-jose[cryptography] 3.3.0

---

## Testing

### Testing Standards

**Test Locations:**
- Auth router tests: `tests/test_routers/test_auth.py`
- Security utils tests: `tests/test_utils/test_security.py`
- JWT utils tests: `tests/test_utils/test_jwt.py`
- Repository tests: `tests/test_repositories/test_user_repository.py`

**Testing Framework:**
- pytest 8.0.0 with pytest-asyncio
- FastAPI TestClient for endpoint testing
- pytest fixtures for test data

**Testing Requirements for This Story:**

1. **Password Hashing Tests (`test_utils/test_security.py`):**
   ```python
   def test_hash_password():
       # Test password is hashed and not reversible
       
   def test_verify_password_correct():
       # Test correct password verification
       
   def test_verify_password_incorrect():
       # Test incorrect password rejected
   ```

2. **JWT Token Tests (`test_utils/test_jwt.py`):**
   ```python
   def test_create_access_token():
       # Test token generation with correct claims
       
   def test_token_expiration():
       # Test token expires after 24 hours
       
   def test_token_decode():
       # Test token can be decoded correctly
   ```

3. **User Repository Tests (`test_repositories/test_user_repository.py`):**
   ```python
   @pytest.mark.asyncio
   async def test_get_by_username_exists(db_session):
       # Test finding existing user
       
   @pytest.mark.asyncio
   async def test_get_by_username_not_found(db_session):
       # Test returns None for nonexistent user
   ```

4. **Login Endpoint Tests (`test_routers/test_auth.py`):**
   ```python
   @pytest.mark.asyncio
   async def test_login_success(client, test_user):
       response = client.post("/api/auth/login", json={
           "username": "\\COLLEGE\\testuser",
           "password": "correctpassword"
       })
       assert response.status_code == 200
       assert "access_token" in response.json()
       assert "Set-Cookie" in response.headers
       
   @pytest.mark.asyncio
   async def test_login_invalid_format(client):
       response = client.post("/api/auth/login", json={
           "username": "invalidformat",
           "password": "password"
       })
       assert response.status_code in [400, 422]
       
   @pytest.mark.asyncio
   async def test_login_user_not_found(client):
       response = client.post("/api/auth/login", json={
           "username": "\\COLLEGE\\nonexistent",
           "password": "password"
       })
       assert response.status_code == 401
       assert response.json()["detail"] == "Invalid username or password"
       
   @pytest.mark.asyncio
   async def test_login_blocked_user(client, blocked_user):
       response = client.post("/api/auth/login", json={
           "username": blocked_user.username,
           "password": "password"
       })
       assert response.status_code == 403
       assert "blocked" in response.json()["detail"].lower()
       
   @pytest.mark.asyncio
   async def test_login_wrong_password(client, test_user):
       response = client.post("/api/auth/login", json={
           "username": test_user.username,
           "password": "wrongpassword"
       })
       assert response.status_code == 401
       assert response.json()["detail"] == "Invalid username or password"
   ```

5. **Test Fixtures:**
   ```python
   @pytest.fixture
   async def test_user(db_session):
       # Create test user with hashed password
       
   @pytest.fixture
   async def blocked_user(db_session):
       # Create blocked test user
   ```

6. **Integration Tests:**
   - [ ] Full login flow with database
   - [ ] Cookie persistence across requests
   - [ ] Token validation on subsequent requests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |

---

## QA Results

### Review Date: December 20, 2025

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Grade: Excellent (A)**

The login API implementation demonstrates high-quality software engineering practices with comprehensive test coverage, proper security measures, and clean architecture. All 25 tests pass successfully across authentication endpoints (10), security utilities (6), JWT generation (5), and repository layer (4).

**Strengths:**
- Well-structured separation of concerns (routers, repositories, schemas, utilities)
- Comprehensive test coverage with edge cases and security scenarios
- Proper use of dependency injection pattern for testability
- Security-first implementation with bcrypt work factor 12 and timing-safe comparisons
- Clear error handling with appropriate HTTP status codes (401, 403, 422)
- Generic error messages prevent user enumeration attacks
- JWT tokens properly include all required claims (user_id, username, exp, iat)
- httpOnly cookies configured correctly (secure=True, samesite='lax')

**Code Quality Highlights:**
- Clean, idiomatic Python with type hints throughout
- Excellent docstrings with examples in utility functions
- Proper async/await patterns for database operations
- Repository pattern abstracts database concerns effectively
- Pydantic validation catches malformed inputs at API boundary

### Requirements Traceability

**AC 1: POST /api/auth/login endpoint** ✓
- **Given** a REST API client
- **When** POST request sent to /api/auth/login with JSON payload
- **Then** endpoint accepts username and password fields
- **Tests:** `test_login_success`, `test_login_missing_fields`

**AC 2: Username format validation** ✓
- **Given** login request with username field
- **When** username doesn't match \\domain\\username pattern
- **Then** returns 422 validation error
- **Tests:** `test_login_invalid_format`, `test_login_invalid_format_missing_domain`

**AC 3: Database query and password verification** ✓
- **Given** valid username format
- **When** endpoint queries database and verifies password with bcrypt
- **Then** authentication succeeds or fails appropriately
- **Tests:** `test_login_success`, `test_login_wrong_password`, `test_verify_password_correct`, `test_verify_password_incorrect`, `test_get_by_username_exists`

**AC 4: Valid credentials handling** ✓
- **Given** correct credentials and non-blocked user
- **When** authentication succeeds
- **Then** JWT token generated and returned in httpOnly cookie + response body
- **Tests:** `test_login_success`, `test_login_jwt_token_structure`

**AC 5: Blocked user handling** ✓
- **Given** user with is_blocked=true
- **When** login attempted
- **Then** returns 403 with specific message about blocked account
- **Tests:** `test_login_blocked_user`, `test_get_blocked_user`

**AC 6: Invalid credentials handling** ✓
- **Given** invalid credentials (wrong password or nonexistent user)
- **When** authentication fails
- **Then** returns 401 with generic message
- **Tests:** `test_login_wrong_password`, `test_login_user_not_found`, `test_login_case_sensitive_password`

**AC 7: JWT token structure** ✓
- **Given** successful authentication
- **When** JWT token generated
- **Then** includes user_id, username, exp (24 hours), and iat claims
- **Tests:** `test_login_jwt_token_structure`, `test_create_access_token`, `test_token_expiration`, `test_token_includes_issued_at`

**AC 8: Unit tests coverage** ✓
- **Given** authentication implementation complete
- **When** test suite executed
- **Then** all scenarios covered: valid login, invalid credentials, blocked user, malformed username
- **Tests:** Complete test suite (25 tests) covering all scenarios

**Coverage Gaps:** None identified for stated requirements.

### Refactoring Performed

No refactoring performed during review. Code quality is excellent as-is.

### Compliance Check

- **Coding Standards:** ✓ Clean Python with type hints, docstrings, proper async patterns
- **Project Structure:** ✓ Follows modular architecture (routers, repositories, schemas, utils)
- **Testing Strategy:** ✓ Comprehensive unit tests at appropriate layers (endpoint, utility, repository)
- **All ACs Met:** ✓ All 8 acceptance criteria fully implemented and tested

### Security Review

**Strengths:**
- ✓ Password hashing uses bcrypt work factor 12 (industry standard)
- ✓ Timing-safe password comparison (bcrypt handles this internally)
- ✓ Generic error messages prevent user enumeration
- ✓ JWT tokens use HS256 signing algorithm
- ✓ httpOnly cookies prevent XSS token theft
- ✓ secure=True flag ensures HTTPS-only cookies
- ✓ samesite='lax' provides CSRF protection
- ✓ Username format validation prevents injection attacks
- ✓ No passwords logged or exposed in responses
- ✓ Proper separation of authentication concerns (401 vs 403)

**Concerns Identified:**

**MEDIUM Severity - Missing Rate Limiting (SEC-001)**
- **Finding:** Login endpoint has no rate limiting protection against brute force attacks
- **Risk:** Attackers can attempt unlimited password guesses
- **Impact:** Authentication bypass via brute force is possible given enough time
- **Recommendation:** Add rate limiting middleware before production (documented in architecture as `slowapi` with 100 requests/minute general limit, 10/minute for sensitive operations)
- **Status:** MUST address before production deployment

**LOW Severity - JWT Secret Key Default Value**
- **Finding:** Default JWT secret key in config.py is placeholder value
- **Risk:** If not changed in production, tokens could be forged
- **Recommendation:** Ensure JWT_SECRET_KEY environment variable is set with cryptographically secure value
- **Status:** Verify during deployment configuration

### Performance Considerations

**Strengths:**
- ✓ Async database operations prevent blocking
- ✓ Repository pattern enables efficient querying
- ✓ JWT tokens are stateless (no session store lookups)
- ✓ Bcrypt work factor 12 balances security and performance

**Notes:**
- Password hashing intentionally slow (~200-300ms) for security
- Database index on username column recommended (likely exists from User model)
- Response time should be <500ms under normal load

### Non-Functional Requirements Assessment

**Security: PASS with CONCERNS**
- Authentication mechanism solid, rate limiting required for production

**Reliability: PASS**
- Proper error handling throughout
- Database failures handled gracefully (would return 500)
- No identified edge cases that could cause crashes

**Maintainability: EXCELLENT**
- Clear separation of concerns
- Comprehensive test coverage enables safe refactoring
- Well-documented code with examples
- Type hints improve IDE support and catch errors

**Testability: EXCELLENT**
- Dependency injection enables easy mocking
- Repository pattern isolates database testing
- Fixtures provide clean test data setup
- Tests are isolated and repeatable

### Technical Debt Assessment

**Identified Debt:**
1. Pydantic V2 deprecation warning - Settings class uses old config style
2. Jose library UTC deprecation warning - Uses deprecated `datetime.utcnow()`
3. Missing asyncio fixture loop scope configuration in pytest

**Impact:** Low - warnings only, no functional issues

**Recommendation:** Address in future housekeeping sprint, not blocking for this story

### Test Architecture Quality

**Test Levels Appropriateness: EXCELLENT**
- Unit tests for utilities (security, JWT) - ✓ Correct level
- Unit tests for repository (database operations) - ✓ Correct level  
- Integration tests for endpoint (full auth flow) - ✓ Correct level
- No unnecessary E2E tests - ✓ Appropriate

**Test Design Quality:**
- Clear test names describe exact scenario
- Proper use of fixtures for test data
- Assertions verify behavior, not implementation
- Edge cases covered (empty password, missing fields, case sensitivity)

**Test Execution:**
- All 25 tests pass
- Execution time: ~8 seconds total (acceptable)
- No flaky tests observed

### Improvements Checklist

**Completed:**
- [x] All 8 acceptance criteria implemented and tested
- [x] Comprehensive test coverage (25 tests)
- [x] Security best practices applied
- [x] Clean architecture with separation of concerns
- [x] Proper error handling and status codes
- [x] Documentation in code via docstrings

**Recommended for Future (Not Blocking):**
- [ ] Add rate limiting middleware (slowapi) - **MUST DO before production**
- [ ] Verify JWT_SECRET_KEY environment variable in deployment checklist
- [ ] Add integration test for token refresh flow (when logout story implemented)
- [ ] Consider adding login attempt tracking for audit/security monitoring
- [ ] Address Pydantic V2 deprecation warnings in next refactoring sprint
- [ ] Add database index on users.username if not present

### Files Modified During Review

None - no code changes needed during review.

### Gate Status

**Gate:** PASS WITH CONCERNS → [docs/qa/gates/1.4-login-api.yml](docs/qa/gates/1.4-login-api.yml)

**Decision Rationale:** Implementation is excellent with comprehensive testing and proper security measures. However, rate limiting must be added before production deployment to protect against brute force attacks. This is documented as a MUST-FIX issue but doesn't block story completion since it's an infrastructure concern that can be addressed during deployment configuration.

### Recommended Status

**✓ Ready for Done** with Production Deployment Checklist:
1. Add rate limiting middleware (slowapi with 10 requests/minute on /api/auth/login)
2. Verify JWT_SECRET_KEY is set to cryptographically secure value
3. Confirm HTTPS is enabled (secure cookie flag requires it)

Story owner should mark as Done and create follow-up task for rate limiting if not already in backlog.
