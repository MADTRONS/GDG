# Story 3.1: Backend PipeCat Room Creation

**Epic:** Epic 3 - Voice Calling Integration  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** backend developer,  
**I want** an API endpoint that creates Daily.co rooms and spawns PipeCat bot instances,  
**so that** voice calling sessions can be initiated for students.

---

## Acceptance Criteria

1. POST /api/voice/create-room endpoint created accepting JSON payload with counselor_category field.
2. Endpoint uses Daily.co API (via DAILY_API_KEY) to create temporary room with properties: enable_chat=true, enable_screenshare=false, max_participants=2.
3. Endpoint generates Daily.co user token for the student and bot token for PipeCat agent.
4. Endpoint spawns PipeCat bot process using subprocess or background task queue (Celery/RQ) with room URL, bot token, and counselor category context.
5. Bot configuration includes: Deepgram STT service, Cartesia TTS service, Google Gemini LLM with counselor category-specific system prompt.
6. Endpoint returns JSON response: { room_url, user_token, room_name, session_id }.
7. Endpoint requires authentication and logs session creation with student ID and category.
8. Error handling: returns 500 if Daily.co API fails, includes detailed error message for debugging.
9. Unit tests mock Daily.co API calls and verify correct room creation logic.

---

## Tasks / Subtasks

- [ ] Install Daily.co Python SDK and dependencies (AC: 2)
  - [ ] Add `daily-python` to requirements.txt
  - [ ] Install PipeCat dependencies
  - [ ] Install Deepgram SDK
  - [ ] Install Cartesia SDK
  - [ ] Add Google Gemini SDK
  - [ ] Document version requirements
  
- [ ] Create Daily.co service adapter (AC: 2, 3)
  - [ ] Create `app/services/daily_service.py`
  - [ ] Implement `create_room()` method
  - [ ] Configure room properties (chat, screenshare, max participants)
  - [ ] Implement `create_user_token()` method
  - [ ] Implement `create_bot_token()` method
  - [ ] Add error handling for API failures
  - [ ] Load DAILY_API_KEY from environment
  
- [ ] Create PipeCat bot service (AC: 4, 5)
  - [ ] Create `app/services/pipecat_service.py`
  - [ ] Implement `spawn_bot()` method
  - [ ] Configure Deepgram STT with API key
  - [ ] Configure Cartesia TTS with API key
  - [ ] Configure Google Gemini LLM with API key
  - [ ] Load system prompt based on category
  - [ ] Use subprocess or background task to spawn bot
  - [ ] Return bot process ID for monitoring
  
- [ ] Create voice session router (AC: 1, 6, 7)
  - [ ] Create `app/routers/voice.py`
  - [ ] Implement POST /create-room endpoint
  - [ ] Define CreateRoomRequest schema (counselor_category)
  - [ ] Define CreateRoomResponse schema
  - [ ] Require authentication with get_current_user
  - [ ] Generate unique session_id (UUID)
  - [ ] Call DailyService to create room and tokens
  - [ ] Call PipeCatService to spawn bot
  - [ ] Return room credentials to frontend
  
- [ ] Create session repository for logging (AC: 7)
  - [ ] Implement `create_session()` method in SessionRepository
  - [ ] Log session_id, user_id, category, started_at
  - [ ] Store room_name for reference
  - [ ] Handle database errors gracefully
  
- [ ] Implement error handling (AC: 8)
  - [ ] Catch Daily.co API exceptions
  - [ ] Catch PipeCat spawn errors
  - [ ] Return 500 with detailed error messages
  - [ ] Log errors with full context for debugging
  - [ ] Clean up resources on failure
  
- [ ] Write comprehensive tests (AC: 9)
  - [ ] Mock Daily.co API calls
  - [ ] Test successful room creation
  - [ ] Test token generation
  - [ ] Test error scenarios (API failure, invalid category)
  - [ ] Test authentication requirement
  - [ ] Test session logging

---

## Dev Notes

### Architecture Overview (From Architecture Document)

**PipeCat Integration Pattern:**
- Reference Repository: https://github.com/mksinha01/agent-starter-embed
- Transport: Daily.co WebRTC
- STT: Deepgram Nova-2
- TTS: Cartesia Sonic-English
- LLM: Google Gemini 2.0 Flash (primary), OpenAI GPT-4 (fallback)

**Room Lifecycle:**
1. Frontend requests room creation
2. Backend creates Daily.co room with 24-hour expiration
3. Backend generates user and bot tokens
4. Backend spawns PipeCat bot process
5. Bot joins Daily.co room and waits for student
6. Student joins room via frontend
7. Real-time conversation begins
8. Session ends when student disconnects or timeout
9. Backend logs session data

### Daily.co Service Implementation

**app/services/daily_service.py:**
```python
import requests
from datetime import datetime, timedelta
from typing import Dict, Optional
from app.config import settings

class DailyService:
    """Service for interacting with Daily.co API."""
    
    def __init__(self):
        self.api_key = settings.DAILY_API_KEY
        self.base_url = "https://api.daily.co/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
    
    async def create_room(self, room_name: str) -> Dict:
        """
        Create a temporary Daily.co room for voice calling.
        
        Args:
            room_name: Unique identifier for the room
            
        Returns:
            Dict with room_url and room configuration
        """
        expires_in_hours = 24
        expires_at = datetime.utcnow() + timedelta(hours=expires_in_hours)
        
        payload = {
            "name": room_name,
            "properties": {
                "enable_chat": True,
                "enable_screenshare": False,
                "max_participants": 2,
                "exp": int(expires_at.timestamp()),
                "enable_recording": False,  # Privacy: no recording by default
                "enable_network_ui": True,  # Show connection quality
            }
        }
        
        try:
            response = requests.post(
                f"{self.base_url}/rooms",
                headers=self.headers,
                json=payload,
                timeout=10
            )
            response.raise_for_status()
            room_data = response.json()
            return {
                "room_url": room_data["url"],
                "room_name": room_data["name"],
                "config": room_data["config"]
            }
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to create Daily.co room: {str(e)}")
    
    async def create_user_token(self, room_name: str, user_id: str) -> str:
        """
        Generate a Daily.co meeting token for a student.
        
        Args:
            room_name: Name of the Daily.co room
            user_id: Student's unique identifier
            
        Returns:
            JWT token for room access
        """
        expires_in_hours = 24
        expires_at = datetime.utcnow() + timedelta(hours=expires_in_hours)
        
        payload = {
            "properties": {
                "room_name": room_name,
                "user_name": f"Student_{user_id[:8]}",
                "is_owner": False,
                "enable_recording": False,
                "exp": int(expires_at.timestamp())
            }
        }
        
        try:
            response = requests.post(
                f"{self.base_url}/meeting-tokens",
                headers=self.headers,
                json=payload,
                timeout=10
            )
            response.raise_for_status()
            return response.json()["token"]
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to create user token: {str(e)}")
    
    async def create_bot_token(self, room_name: str) -> str:
        """
        Generate a Daily.co meeting token for the PipeCat bot.
        
        Args:
            room_name: Name of the Daily.co room
            
        Returns:
            JWT token for bot room access
        """
        expires_in_hours = 24
        expires_at = datetime.utcnow() + timedelta(hours=expires_in_hours)
        
        payload = {
            "properties": {
                "room_name": room_name,
                "user_name": "Counselor",
                "is_owner": True,  # Bot has owner privileges
                "enable_recording": False,
                "exp": int(expires_at.timestamp())
            }
        }
        
        try:
            response = requests.post(
                f"{self.base_url}/meeting-tokens",
                headers=self.headers,
                json=payload,
                timeout=10
            )
            response.raise_for_status()
            return response.json()["token"]
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to create bot token: {str(e)}")
    
    async def delete_room(self, room_name: str) -> bool:
        """Delete a Daily.co room (cleanup after session ends)."""
        try:
            response = requests.delete(
                f"{self.base_url}/rooms/{room_name}",
                headers=self.headers,
                timeout=10
            )
            response.raise_for_status()
            return True
        except requests.exceptions.RequestException:
            return False
```

### PipeCat Bot Service Implementation

**app/services/pipecat_service.py:**
```python
import asyncio
import subprocess
import os
from typing import Dict
from app.config import settings
from app.repositories.counselor_repository import CounselorRepository

class PipeCatService:
    """Service for spawning and managing PipeCat bot instances."""
    
    def __init__(self, counselor_repo: CounselorRepository):
        self.counselor_repo = counselor_repo
    
    async def spawn_bot(
        self,
        room_url: str,
        bot_token: str,
        session_id: str,
        category_id: str
    ) -> Dict:
        """
        Spawn a PipeCat bot instance for a voice session.
        
        Args:
            room_url: Daily.co room URL
            bot_token: Authentication token for bot
            session_id: Unique session identifier
            category_id: Counselor category UUID
            
        Returns:
            Dict with bot process information
        """
        # Get category system prompt
        category = await self.counselor_repo.get_by_id(category_id)
        if not category:
            raise ValueError(f"Invalid counselor category: {category_id}")
        
        system_prompt = category.system_prompt or self._get_default_prompt()
        
        # Prepare environment variables for bot process
        env = os.environ.copy()
        env.update({
            "DAILY_ROOM_URL": room_url,
            "DAILY_TOKEN": bot_token,
            "SESSION_ID": session_id,
            "DEEPGRAM_API_KEY": settings.DEEPGRAM_API_KEY,
            "CARTESIA_API_KEY": settings.CARTESIA_API_KEY,
            "GOOGLE_API_KEY": settings.GOOGLE_API_KEY,
            "OPENAI_API_KEY": settings.OPENAI_API_KEY,  # Fallback
            "SYSTEM_PROMPT": system_prompt,
            "COUNSELOR_CATEGORY": category.name
        })
        
        # Path to PipeCat bot script
        bot_script_path = os.path.join(
            os.path.dirname(__file__),
            "..", "..", "pipecat_bot", "voice_bot.py"
        )
        
        try:
            # Spawn bot as background process
            process = subprocess.Popen(
                ["python", bot_script_path],
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                start_new_session=True
            )
            
            return {
                "process_id": process.pid,
                "session_id": session_id,
                "status": "spawned"
            }
            
        except Exception as e:
            raise Exception(f"Failed to spawn PipeCat bot: {str(e)}")
    
    def _get_default_prompt(self) -> str:
        """Fallback system prompt if category doesn't have one."""
        return """You are a supportive counselor helping college students. 
        Be empathetic, professional, and non-judgmental. 
        Ask clarifying questions and provide actionable guidance."""
```

### Voice Router Implementation

**app/routers/voice.py:**
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, UUID4
from typing import Dict
import uuid

from app.database import get_db
from app.utils.dependencies import get_current_user
from app.services.daily_service import DailyService
from app.services.pipecat_service import PipeCatService
from app.repositories.session_repository import SessionRepository
from app.repositories.counselor_repository import CounselorRepository

router = APIRouter(prefix="/voice", tags=["voice"])

class CreateRoomRequest(BaseModel):
    counselor_category: UUID4

class CreateRoomResponse(BaseModel):
    room_url: str
    user_token: str
    room_name: str
    session_id: UUID4

@router.post(
    "/create-room",
    response_model=CreateRoomResponse,
    summary="Create voice calling room",
    description="Creates a Daily.co room and spawns PipeCat bot for voice counseling session."
)
async def create_room(
    request: CreateRoomRequest,
    current_user: Dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a voice calling session room.
    
    1. Validates counselor category exists
    2. Creates Daily.co room with temporary access
    3. Generates user and bot tokens
    4. Spawns PipeCat bot instance
    5. Logs session to database
    6. Returns room credentials to frontend
    """
    # Initialize services
    daily_service = DailyService()
    counselor_repo = CounselorRepository(db)
    pipecat_service = PipeCatService(counselor_repo)
    session_repo = SessionRepository(db)
    
    # Generate unique identifiers
    session_id = uuid.uuid4()
    room_name = f"voice-{session_id}"
    
    try:
        # Verify category exists and is enabled
        category = await counselor_repo.get_by_id(str(request.counselor_category))
        if not category or not category.enabled:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Counselor category not found or disabled"
            )
        
        # Create Daily.co room
        room_data = await daily_service.create_room(room_name)
        room_url = room_data["room_url"]
        
        # Generate tokens
        user_token = await daily_service.create_user_token(
            room_name,
            current_user["user_id"]
        )
        bot_token = await daily_service.create_bot_token(room_name)
        
        # Spawn PipeCat bot
        bot_info = await pipecat_service.spawn_bot(
            room_url=room_url,
            bot_token=bot_token,
            session_id=str(session_id),
            category_id=str(request.counselor_category)
        )
        
        # Log session to database
        await session_repo.create_session(
            session_id=session_id,
            user_id=uuid.UUID(current_user["user_id"]),
            counselor_category=category.name,
            mode="voice",
            room_name=room_name
        )
        
        return CreateRoomResponse(
            room_url=room_url,
            user_token=user_token,
            room_name=room_name,
            session_id=session_id
        )
        
    except HTTPException:
        raise
    except Exception as e:
        # Log error with full context
        print(f"Error creating voice room: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create voice session: {str(e)}"
        )
```

### Environment Variables Required

Add to .env:
```bash
# Daily.co
DAILY_API_KEY=your-daily-api-key

# Speech Services
DEEPGRAM_API_KEY=your-deepgram-api-key
CARTESIA_API_KEY=your-cartesia-api-key

# LLM Services
GOOGLE_API_KEY=your-gemini-api-key
OPENAI_API_KEY=your-openai-api-key
```

### Session Repository Updates

**app/repositories/session_repository.py (additions):**
```python
from uuid import UUID
from datetime import datetime
from sqlalchemy import select
from app.models.session import Session

class SessionRepository:
    # ... existing methods ...
    
    async def create_session(
        self,
        session_id: UUID,
        user_id: UUID,
        counselor_category: str,
        mode: str,
        room_name: str
    ) -> Session:
        """Create a new session record."""
        session = Session(
            id=session_id,
            user_id=user_id,
            counselor_category=counselor_category,
            mode=mode,
            room_name=room_name,
            started_at=datetime.utcnow()
        )
        self.session.add(session)
        await self.session.commit()
        await self.session.refresh(session)
        return session
```

### Source Tree Updates

New files to create:
```
packages/backend/
├── app/
│   ├── services/
│   │   ├── daily_service.py       # Daily.co API integration
│   │   └── pipecat_service.py     # PipeCat bot management
│   ├── routers/
│   │   └── voice.py               # Voice session endpoints
│   └── repositories/
│       └── session_repository.py  # Session data access (update)
└── pipecat_bot/
    └── voice_bot.py                # PipeCat bot script (Story 3.2)
```

---

## Testing

### Testing Standards

**Test Locations:**
- Service tests: `tests/test_services/`
- Router tests: `tests/test_routers/test_voice.py`
- Integration tests: `tests/integration/test_voice_creation.py`

**Testing Framework:**
- pytest 8.0.0 with pytest-asyncio
- pytest-mock for mocking external APIs
- responses library for HTTP mocking

**Testing Requirements for This Story:**

1. **Daily.co Service Tests:**
   ```python
   import pytest
   import responses
   from app.services.daily_service import DailyService
   
   @pytest.mark.asyncio
   async def test_create_room_success():
       service = DailyService()
       
       with responses.RequestsMock() as rsps:
           rsps.add(
               responses.POST,
               "https://api.daily.co/v1/rooms",
               json={
                   "url": "https://example.daily.co/test-room",
                   "name": "test-room",
                   "config": {}
               },
               status=200
           )
           
           result = await service.create_room("test-room")
           
           assert result["room_url"] == "https://example.daily.co/test-room"
           assert result["room_name"] == "test-room"
   
   @pytest.mark.asyncio
   async def test_create_room_api_failure():
       service = DailyService()
       
       with responses.RequestsMock() as rsps:
           rsps.add(
               responses.POST,
               "https://api.daily.co/v1/rooms",
               json={"error": "API error"},
               status=500
           )
           
           with pytest.raises(Exception, match="Failed to create Daily.co room"):
               await service.create_room("test-room")
   
   @pytest.mark.asyncio
   async def test_create_user_token():
       service = DailyService()
       
       with responses.RequestsMock() as rsps:
           rsps.add(
               responses.POST,
               "https://api.daily.co/v1/meeting-tokens",
               json={"token": "user-token-123"},
               status=200
           )
           
           token = await service.create_user_token("test-room", "user-id")
           
           assert token == "user-token-123"
   ```

2. **PipeCat Service Tests:**
   ```python
   @pytest.mark.asyncio
   async def test_spawn_bot_success(mock_counselor_repo):
       service = PipeCatService(mock_counselor_repo)
       
       # Mock category
       mock_category = MagicMock()
       mock_category.name = "Health"
       mock_category.system_prompt = "Test prompt"
       mock_counselor_repo.get_by_id.return_value = mock_category
       
       with patch('subprocess.Popen') as mock_popen:
           mock_popen.return_value.pid = 12345
           
           result = await service.spawn_bot(
               room_url="https://example.daily.co/room",
               bot_token="bot-token",
               session_id="session-123",
               category_id="category-456"
           )
           
           assert result["process_id"] == 12345
           assert result["status"] == "spawned"
           mock_popen.assert_called_once()
   
   @pytest.mark.asyncio
   async def test_spawn_bot_invalid_category(mock_counselor_repo):
       service = PipeCatService(mock_counselor_repo)
       mock_counselor_repo.get_by_id.return_value = None
       
       with pytest.raises(ValueError, match="Invalid counselor category"):
           await service.spawn_bot(
               room_url="url",
               bot_token="token",
               session_id="session",
               category_id="invalid"
           )
   ```

3. **Voice Router Tests:**
   ```python
   @pytest.mark.asyncio
   async def test_create_room_endpoint(client, authenticated_user, mock_services):
       response = client.post(
           "/api/v1/voice/create-room",
           json={"counselor_category": "valid-uuid"},
           headers=authenticated_user.headers
       )
       
       assert response.status_code == 200
       data = response.json()
       
       assert "room_url" in data
       assert "user_token" in data
       assert "room_name" in data
       assert "session_id" in data
   
   @pytest.mark.asyncio
   async def test_create_room_requires_authentication(client):
       response = client.post(
           "/api/v1/voice/create-room",
           json={"counselor_category": "valid-uuid"}
       )
       
       assert response.status_code == 401
   
   @pytest.mark.asyncio
   async def test_create_room_invalid_category(client, authenticated_user):
       response = client.post(
           "/api/v1/voice/create-room",
           json={"counselor_category": "00000000-0000-0000-0000-000000000000"},
           headers=authenticated_user.headers
       )
       
       assert response.status_code == 404
       assert "not found" in response.json()["detail"].lower()
   ```

4. **Integration Tests:**
   ```python
   @pytest.mark.asyncio
   @pytest.mark.integration
   async def test_full_room_creation_flow(client, test_user, test_category):
       # Login
       login_response = client.post("/api/v1/auth/login", json={
           "username": test_user.username,
           "password": "testpassword"
       })
       assert login_response.status_code == 200
       
       # Create room
       room_response = client.post(
           "/api/v1/voice/create-room",
           json={"counselor_category": str(test_category.id)}
       )
       
       assert room_response.status_code == 200
       room_data = room_response.json()
       
       # Verify session logged
       session_response = client.get("/api/v1/sessions")
       sessions = session_response.json()
       
       assert any(s["id"] == room_data["session_id"] for s in sessions)
   ```

5. **Manual Testing Checklist:**
   - [ ] POST /api/v1/voice/create-room returns room credentials
   - [ ] Daily.co room is created successfully
   - [ ] User token is valid
   - [ ] Bot token is valid
   - [ ] PipeCat bot process spawns
   - [ ] Session logged to database with correct data
   - [ ] Endpoint requires authentication
   - [ ] Invalid category returns 404
   - [ ] Daily.co API failure returns 500 with error message
   - [ ] Bot spawn failure returns 500 with error message
   - [ ] Room expires after 24 hours
   - [ ] Max 2 participants enforced
   - [ ] Chat enabled, screenshare disabled

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
