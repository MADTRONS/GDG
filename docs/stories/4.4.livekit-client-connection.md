# Story 4.4: LiveKit Client Connection and Video Rendering

**Epic:** Epic 4 - Video Calling Integration  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** student user,  
**I want** to see the counselor avatar on my screen and have two-way audio,  
**so that** I can have a natural video counseling session.

---

## Acceptance Criteria

1. Frontend initializes LiveKit Room client using access_token from backend.
2. Client configured with: audio enabled (student microphone), video subscribe enabled (avatar video), camera disabled for student (audio-only participation).
3. Browser requests microphone permissions; if denied, display error with instructions.
4. On room connection, client listens for "trackSubscribed" event to receive avatar video track.
5. Avatar video track rendered in HTML5 video element with autoplay enabled, filling majority of screen space.
6. Video aspect ratio maintained (16:9 or avatar default), no stretching or distortion.
7. Audio from avatar plays automatically through device speakers with no manual setup required.
8. If connection fails or avatar doesn't join within 30 seconds, display error and offer retry or fallback to voice-only.
9. Client handles "disconnected" event for cleanup and redirects to dashboard with session summary.

---

## Tasks / Subtasks

- [ ] Install LiveKit client dependencies (AC: 1)
  - [ ] Add livekit-client to package.json
  - [ ] Add @livekit/components-react for React integration
  - [ ] Install necessary types
  - [ ] Document version compatibility
  
- [ ] Create VideoSessionPage component (AC: 1)
  - [ ] Extract query params (room_url, access_token, session_id, category)
  - [ ] Validate required params are present
  - [ ] Show error UI if params missing
  - [ ] Display counselor category name
  
- [ ] Initialize LiveKit Room (AC: 1, 2)
  - [ ] Import LiveKit Room
  - [ ] Configure room with access token
  - [ ] Set audio enabled, video disabled for local participant
  - [ ] Connect to room on component mount
  - [ ] Handle connection lifecycle
  
- [ ] Request microphone permissions (AC: 3)
  - [ ] Use navigator.mediaDevices.getUserMedia
  - [ ] Handle permission denied scenario
  - [ ] Show permission prompt UI
  - [ ] Enable audio input when granted
  
- [ ] Implement connection status UI
  - [ ] Show "Connecting..." spinner during connection
  - [ ] Show "Connected" indicator
  - [ ] Show "Waiting for avatar..." while avatar joins
  - [ ] Display connection quality indicator
  
- [ ] Handle avatar video track subscription (AC: 4, 5, 6)
  - [ ] Listen for trackSubscribed event
  - [ ] Filter for video tracks from avatar participant
  - [ ] Attach video track to video element
  - [ ] Enable autoplay
  - [ ] Maintain aspect ratio (object-fit: contain)
  
- [ ] Handle avatar audio track subscription (AC: 7)
  - [ ] Listen for audio tracks from avatar
  - [ ] Audio plays automatically through default output
  - [ ] Handle audio device selection
  
- [ ] Implement error handling (AC: 8)
  - [ ] Handle connection timeout (30s)
  - [ ] Handle network disconnection
  - [ ] Handle permission denied
  - [ ] Show retry button on errors
  - [ ] Offer fallback to voice-only mode
  - [ ] Log errors for debugging
  
- [ ] Implement session end functionality (AC: 9)
  - [ ] Add "End Session" button
  - [ ] Show confirmation dialog
  - [ ] Disconnect LiveKit Room
  - [ ] Clean up video/audio resources
  - [ ] Navigate to dashboard
  
- [ ] Write comprehensive tests
  - [ ] Unit test room initialization
  - [ ] Mock LiveKit Room connection
  - [ ] Test permission handling
  - [ ] Test track subscription
  - [ ] Test error scenarios
  - [ ] Test session end flow

---

## Dev Notes

### Architecture Overview

**LiveKit Client Architecture:**
- Room: Main connection object
- LocalParticipant: Student (audio only)
- RemoteParticipant: Avatar (audio + video)
- Tracks: Audio and video streams

**Connection Flow:**
1. User lands on /video-session with room credentials
2. LiveKit Room initialized with access token
3. Room connects to LiveKit server
4. Microphone permission requested
5. Avatar already in room (spawned by backend in Story 4.1)
6. Avatar video/audio tracks subscribed
7. Video rendered, audio plays
8. User speaks → Avatar hears → Avatar responds → User sees/hears

### Video Session Page Implementation

**app/video-session/page.tsx:**
```typescript
'use client';

import { useEffect, useState, useRef, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Room, RoomEvent, Track } from 'livekit-client';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { PhoneOff, Loader2, Video as VideoIcon } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';

type ConnectionState = 'idle' | 'connecting' | 'connected' | 'waiting_avatar' | 'disconnected' | 'error';

function VideoSessionContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const { toast } = useToast();

  // Extract room credentials from URL
  const roomUrl = searchParams.get('room_url');
  const accessToken = searchParams.get('access_token');
  const sessionId = searchParams.get('session_id');
  const category = searchParams.get('category') || 'Counselor';

  // State
  const [connectionState, setConnectionState] = useState<ConnectionState>('idle');
  const [showEndDialog, setShowEndDialog] = useState(false);
  const [permissionDenied, setPermissionDenied] = useState(false);
  const [avatarVideoTrack, setAvatarVideoTrack] = useState<MediaStreamTrack | null>(null);

  // Refs
  const roomRef = useRef<Room | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const hasConnected = useRef(false);
  const avatarJoinTimeout = useRef<NodeJS.Timeout | null>(null);

  // Validate params
  useEffect(() => {
    if (!roomUrl || !accessToken || !sessionId) {
      toast({
        title: "Invalid Session",
        description: "Missing required session parameters. Returning to dashboard.",
        variant: "destructive"
      });
      router.push('/dashboard');
    }
  }, [roomUrl, accessToken, sessionId, router, toast]);

  // Initialize LiveKit Room and connect
  useEffect(() => {
    if (!roomUrl || !accessToken || hasConnected.current) return;

    const initializeRoom = async () => {
      try {
        setConnectionState('connecting');

        // Request microphone permission
        try {
          await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (permError) {
          console.error('Microphone permission denied:', permError);
          setPermissionDenied(true);
          setConnectionState('error');
          toast({
            title: "Microphone Required",
            description: "Please allow microphone access to join the video session.",
            variant: "destructive"
          });
          return;
        }

        // Initialize LiveKit Room
        const room = new Room({
          adaptiveStream: true,
          dynacast: true,
          videoCaptureDefaults: {
            resolution: { width: 1280, height: 720 },
          },
        });

        // Set up event listeners
        room.on(RoomEvent.Connected, () => {
          console.log('Connected to room');
          setConnectionState('waiting_avatar');
          
          // Start timeout for avatar joining
          avatarJoinTimeout.current = setTimeout(() => {
            if (connectionState === 'waiting_avatar') {
              setConnectionState('error');
              toast({
                title: "Avatar Connection Timeout",
                description: "The counselor avatar didn't join. Please try again.",
                variant: "destructive"
              });
            }
          }, 30000); // 30 second timeout
        });

        room.on(RoomEvent.TrackSubscribed, (track, publication, participant) => {
          console.log('Track subscribed:', track.kind, 'from', participant.identity);
          
          // Check if this is the avatar's video track
          if (participant.identity.includes('avatar') && track.kind === Track.Kind.Video) {
            console.log('Avatar video track received');
            
            // Clear avatar join timeout
            if (avatarJoinTimeout.current) {
              clearTimeout(avatarJoinTimeout.current);
            }
            
            setConnectionState('connected');
            setAvatarVideoTrack(track.mediaStreamTrack);
            
            toast({
              title: "Connected",
              description: `You're now connected to ${category}. The avatar can see and hear you.`
            });
          }
          
          // Audio tracks play automatically
          if (track.kind === Track.Kind.Audio) {
            track.attach();  // Attach to default audio output
          }
        });

        room.on(RoomEvent.Disconnected, () => {
          console.log('Disconnected from room');
          setConnectionState('disconnected');
        });

        room.on(RoomEvent.ConnectionQualityChanged, (quality, participant) => {
          console.log('Connection quality:', quality, 'for', participant.identity);
          // Could update UI with quality indicator
        });

        // Connect to room
        await room.connect(roomUrl, accessToken);
        roomRef.current = room;
        hasConnected.current = true;

      } catch (error) {
        console.error('Failed to initialize LiveKit room:', error);
        setConnectionState('error');
        toast({
          title: "Connection Failed",
          description: error instanceof Error ? error.message : "Unable to connect to video session.",
          variant: "destructive"
        });
      }
    };

    initializeRoom();

    // Cleanup on unmount
    return () => {
      if (avatarJoinTimeout.current) {
        clearTimeout(avatarJoinTimeout.current);
      }
      if (roomRef.current) {
        roomRef.current.disconnect();
        roomRef.current = null;
      }
    };
  }, [roomUrl, accessToken, category, toast]);

  // Attach avatar video track to video element
  useEffect(() => {
    if (avatarVideoTrack && videoRef.current) {
      const stream = new MediaStream([avatarVideoTrack]);
      videoRef.current.srcObject = stream;
      videoRef.current.play().catch(err => {
        console.error('Failed to play video:', err);
      });
    }
  }, [avatarVideoTrack]);

  // End session handler
  const handleEndSession = async () => {
    if (roomRef.current) {
      await roomRef.current.disconnect();
    }
    
    toast({
      title: "Session Ended",
      description: "Your video counseling session has ended. Take care!"
    });
    
    router.push('/dashboard');
  };

  // Retry connection
  const retryConnection = () => {
    hasConnected.current = false;
    setConnectionState('idle');
    window.location.reload();
  };

  // Render connection status
  const renderConnectionStatus = () => {
    switch (connectionState) {
      case 'connecting':
        return (
          <div className="flex items-center gap-2 text-blue-600">
            <Loader2 className="h-4 w-4 animate-spin" />
            <span>Connecting to room...</span>
          </div>
        );
      case 'waiting_avatar':
        return (
          <div className="flex items-center gap-2 text-yellow-600">
            <Loader2 className="h-4 w-4 animate-spin" />
            <span>Waiting for {category} avatar to join...</span>
          </div>
        );
      case 'connected':
        return (
          <div className="flex items-center gap-2 text-green-600">
            <div className="h-3 w-3 rounded-full bg-green-600 animate-pulse" />
            <span>Connected</span>
          </div>
        );
      case 'disconnected':
        return (
          <div className="flex items-center gap-2 text-red-600">
            <div className="h-3 w-3 rounded-full bg-red-600" />
            <span>Disconnected</span>
          </div>
        );
      case 'error':
        return (
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2 text-red-600">
              <div className="h-3 w-3 rounded-full bg-red-600" />
              <span>Connection Error</span>
            </div>
            <Button onClick={retryConnection} variant="outline" size="sm">
              Retry Connection
            </Button>
          </div>
        );
      default:
        return null;
    }
  };

  // Handle permission denied state
  if (permissionDenied) {
    return (
      <div className="container mx-auto flex items-center justify-center min-h-screen p-4">
        <Card className="max-w-md">
          <CardHeader>
            <CardTitle>Microphone Access Required</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-muted-foreground">
              Video calling requires microphone access. Please enable microphone permissions in your browser settings and reload the page.
            </p>
            <div className="flex gap-2">
              <Button onClick={() => window.location.reload()} className="flex-1">
                Try Again
              </Button>
              <Button onClick={() => router.push('/dashboard')} variant="outline" className="flex-1">
                Go Back
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto flex flex-col min-h-screen p-4 bg-black">
      {/* Header */}
      <div className="flex items-center justify-between p-4 bg-gray-900 rounded-t-lg">
        <div>
          <h1 className="text-xl font-bold text-white">Video Session: {category}</h1>
          <p className="text-sm text-gray-400">Session ID: {sessionId}</p>
        </div>
        {renderConnectionStatus()}
      </div>

      {/* Main video area */}
      <div className="flex-1 flex items-center justify-center bg-gray-900 p-4">
        {avatarVideoTrack ? (
          <video
            ref={videoRef}
            autoPlay
            playsInline
            className="max-w-full max-h-full object-contain rounded-lg shadow-2xl"
            style={{ aspectRatio: '16/9' }}
          />
        ) : (
          <div className="flex flex-col items-center gap-4 text-white">
            <Loader2 className="h-16 w-16 animate-spin text-blue-500" />
            <p className="text-lg">
              {connectionState === 'connecting' 
                ? 'Connecting to video session...'
                : connectionState === 'waiting_avatar'
                ? 'Waiting for avatar to appear...'
                : 'Initializing...'}
            </p>
          </div>
        )}
      </div>

      {/* Controls */}
      <div className="p-4 bg-gray-900 rounded-b-lg">
        <div className="flex items-center justify-center gap-4">
          <Button
            onClick={() => setShowEndDialog(true)}
            variant="destructive"
            size="lg"
          >
            <PhoneOff className="mr-2 h-5 w-5" />
            End Session
          </Button>
        </div>
        
        <div className="text-xs text-gray-400 text-center mt-4">
          <p>If you're in crisis, call 988 (Suicide & Crisis Lifeline) immediately.</p>
        </div>
      </div>

      {/* End session confirmation dialog */}
      <AlertDialog open={showEndDialog} onOpenChange={setShowEndDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>End Video Session?</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to end this counseling session? You can always start a new session from the dashboard.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Stay in Session</AlertDialogCancel>
            <AlertDialogAction onClick={handleEndSession}>
              End Session
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

export default function VideoSessionPage() {
  return (
    <Suspense fallback={
      <div className="flex items-center justify-center min-h-screen bg-black">
        <Loader2 className="h-8 w-8 animate-spin text-white" />
      </div>
    }>
      <VideoSessionContent />
    </Suspense>
  );
}
```

### TypeScript Types

**types/video.ts:**
```typescript
import { Track } from 'livekit-client';

export type ConnectionState = 'idle' | 'connecting' | 'connected' | 'waiting_avatar' | 'disconnected' | 'error';

export interface VideoSessionParams {
  room_url: string;
  access_token: string;
  session_id: string;
  category: string;
}

export interface AvatarTrack {
  video: MediaStreamTrack | null;
  audio: MediaStreamTrack | null;
}
```

### Source Tree Updates

```
packages/frontend/
├── app/
│   └── video-session/
│       └── page.tsx              # Full video session implementation
└── types/
    └── video.ts                  # Video session types
```

---

## Testing

### Testing Requirements:

1. **Room Initialization Test:**
   ```typescript
   import { render, screen, waitFor } from '@testing-library/react';
   import { vi } from 'vitest';
   import VideoSessionPage from '@/app/video-session/page';
   import { Room } from 'livekit-client';

   vi.mock('livekit-client');

   describe('VideoSessionPage', () => {
     const mockSearchParams = {
       get: vi.fn((key: string) => {
         const params: any = {
           room_url: 'wss://livekit.example.com',
           access_token: 'token-123',
           session_id: 'session-456',
           category: 'Health Counselor'
         };
         return params[key];
       })
     };

     beforeEach(() => {
       vi.mocked(useSearchParams).mockReturnValue(mockSearchParams as any);
       global.navigator.mediaDevices = {
         getUserMedia: vi.fn().mockResolvedValue({})
       } as any;
     });

     it('initializes LiveKit Room with correct params', async () => {
       const mockRoom = {
         connect: vi.fn().mockResolvedValue(undefined),
         on: vi.fn(),
         disconnect: vi.fn()
       };

       vi.mocked(Room).mockImplementation(() => mockRoom as any);

       render(<VideoSessionPage />);

       await waitFor(() => {
         expect(mockRoom.connect).toHaveBeenCalledWith(
           'wss://livekit.example.com',
           'token-123'
         );
       });
     });

     it('shows connecting state initially', () => {
       render(<VideoSessionPage />);
       expect(screen.getByText(/connecting to room/i)).toBeInTheDocument();
     });

     it('handles microphone permission denied', async () => {
       global.navigator.mediaDevices.getUserMedia = vi.fn().mockRejectedValue(
         new Error('Permission denied')
       );

       render(<VideoSessionPage />);

       await waitFor(() => {
         expect(screen.getByText(/microphone access required/i)).toBeInTheDocument();
       });
     });
   });
   ```

2. **Video Track Rendering Test:**
   ```typescript
   it('renders avatar video when track received', async () => {
     const mockVideoTrack = new MediaStreamTrack();
     
     const mockRoom = {
       connect: vi.fn(),
       on: vi.fn((event, handler) => {
         if (event === 'trackSubscribed') {
           // Simulate avatar video track subscription
           handler(
             { kind: 'video', mediaStreamTrack: mockVideoTrack },
             {},
             { identity: 'avatar-agent' }
           );
         }
       }),
       disconnect: vi.fn()
     };

     render(<VideoSessionPage />);

     await waitFor(() => {
       const video = screen.getByRole('video');
       expect(video).toBeInTheDocument();
     });
   });
   ```

3. **Manual Testing Checklist:**
   - [ ] Video session page loads with room credentials
   - [ ] Browser requests microphone permission
   - [ ] Connection status shows "Connecting..." then "Waiting for avatar..."
   - [ ] Avatar video appears when avatar joins
   - [ ] Video fills screen appropriately
   - [ ] Video aspect ratio maintained (no stretching)
   - [ ] Avatar audio plays automatically
   - [ ] User can hear avatar speak
   - [ ] End session button shows confirmation dialog
   - [ ] End session disconnects and navigates to dashboard
   - [ ] Connection timeout (30s) shows error if avatar doesn't join
   - [ ] Permission denied shows helpful error message
   - [ ] Retry button works after errors
   - [ ] Session ID displayed for support reference
   - [ ] Crisis hotline info visible

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
