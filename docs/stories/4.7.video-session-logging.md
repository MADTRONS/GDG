# Story 4.7: Video Session Logging

**Epic:** Epic 4 - Video Calling Integration  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** student user,  
**I want** my video sessions logged to my session history,  
**so that** I can review past conversations and track my progress.

---

## Acceptance Criteria

1. Video session saved to database with mode="video" when session ends.
2. Session record includes: session_id, user_id, counselor_category, start_time, end_time, duration_seconds, transcript, video_quality_metrics.
3. Transcript captured in real-time during session using OpenAI Whisper transcription.
4. Video quality metrics logged: average_bitrate, average_fps, packet_loss_percentage, connection_quality_average.
5. POST /api/sessions/save endpoint accepts video session data (same endpoint as voice, Story 3.7).
6. Session saved automatically when user ends session or connection drops.
7. Failed save attempts retry up to 3 times with exponential backoff.
8. User sees confirmation toast after successful session save: "Session saved to your history".
9. Video sessions appear in Session History page with video icon to distinguish from voice sessions.

---

## Tasks / Subtasks

- [ ] Capture real-time transcript during video session (AC: 3)
  - [ ] Integrate OpenAI Whisper for student speech transcription
  - [ ] Receive counselor transcript from LiveKit data channel
  - [ ] Store transcript messages in state
  - [ ] Format transcript for database storage
  
- [ ] Track video quality metrics throughout session (AC: 4)
  - [ ] Monitor bitrate every 10 seconds
  - [ ] Monitor frame rate every 10 seconds
  - [ ] Track packet loss events
  - [ ] Track connection quality changes
  - [ ] Calculate averages on session end
  
- [ ] Implement session save logic (AC: 1, 2, 5, 6)
  - [ ] Create saveVideoSession function
  - [ ] Construct session payload with all required fields
  - [ ] Call POST /api/sessions/save on session end
  - [ ] Set mode="video" in payload
  - [ ] Include video quality metrics
  - [ ] Trigger save on "End Session" button click
  - [ ] Trigger save on connection drop
  - [ ] Trigger save on page unload (beforeunload event)
  
- [ ] Implement retry logic for failed saves (AC: 7)
  - [ ] Retry up to 3 times
  - [ ] Use exponential backoff (1s, 2s, 4s)
  - [ ] Log retry attempts
  - [ ] Show error if all retries fail
  
- [ ] Add user feedback for session save (AC: 8)
  - [ ] Show success toast: "Session saved to your history"
  - [ ] Show error toast if save fails: "Failed to save session"
  - [ ] Include session ID in success message
  
- [ ] Update Session History page to show video sessions (AC: 9)
  - [ ] Add video icon for mode="video" sessions
  - [ ] Display video quality metrics in session detail
  - [ ] Show session duration
  - [ ] Link to transcript view
  
- [ ] Write comprehensive tests
  - [ ] Test transcript capture
  - [ ] Test quality metrics tracking
  - [ ] Test session save on end
  - [ ] Test session save on disconnect
  - [ ] Test retry logic
  - [ ] Test toast notifications
  - [ ] Test session history display

---

## Dev Notes

### Architecture Overview

**Session Logging Flow:**
1. Video session starts: initialize quality tracking
2. During session: capture transcript + quality metrics
3. Session ends: calculate averages, construct payload
4. Save to database: POST /api/sessions/save
5. Display confirmation: success toast
6. Session appears in history: /session-history page

**Database Schema (same as Story 3.7, supports video):**
```sql
CREATE TABLE sessions (
    session_id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(user_id),
    counselor_category UUID REFERENCES counselor_categories(category_id),
    mode VARCHAR(10) CHECK (mode IN ('voice', 'video')),
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    duration_seconds INTEGER,
    transcript JSONB,  -- Array of {speaker, text, timestamp}
    quality_metrics JSONB,  -- Video/voice quality data
    created_at TIMESTAMP DEFAULT NOW()
);
```

### Video Session with Logging

**app/video-session/page.tsx (updated from Story 4.6):**
```typescript
'use client';

import { useEffect, useState, useRef, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Room, RoomEvent, Track } from 'livekit-client';
import { useToast } from '@/components/ui/use-toast';

interface TranscriptMessage {
  speaker: 'user' | 'counselor';
  text: string;
  timestamp: Date;
}

interface VideoQualityMetrics {
  bitrateReadings: number[];
  fpsReadings: number[];
  packetLossEvents: number;
  connectionQualityReadings: string[];
}

function VideoSessionContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const { toast } = useToast();

  const roomUrl = searchParams.get('room_url');
  const accessToken = searchParams.get('access_token');
  const sessionId = searchParams.get('session_id');
  const category = searchParams.get('category') || 'Counselor';

  const [transcript, setTranscript] = useState<TranscriptMessage[]>([]);
  const [sessionStartTime] = useState<Date>(new Date());
  const [qualityMetrics, setQualityMetrics] = useState<VideoQualityMetrics>({
    bitrateReadings: [],
    fpsReadings: [],
    packetLossEvents: 0,
    connectionQualityReadings: []
  });

  const roomRef = useRef<Room | null>(null);
  const qualityMonitorInterval = useRef<NodeJS.Timeout | null>(null);
  const sessionSaved = useRef(false);

  // Monitor video quality metrics
  useEffect(() => {
    if (!roomRef.current) return;

    qualityMonitorInterval.current = setInterval(async () => {
      const room = roomRef.current;
      if (!room) return;

      // Get stats from LiveKit
      const stats = await room.localParticipant.getStats();
      
      // Extract video stats
      stats.forEach(stat => {
        if (stat.type === 'outbound-rtp' && stat.mediaType === 'video') {
          const bitrate = stat.bytesSent * 8 / 1000; // kbps
          setQualityMetrics(prev => ({
            ...prev,
            bitrateReadings: [...prev.bitrateReadings, bitrate]
          }));
        }
        
        if (stat.type === 'track' && stat.kind === 'video') {
          const fps = stat.framesPerSecond || 0;
          setQualityMetrics(prev => ({
            ...prev,
            fpsReadings: [...prev.fpsReadings, fps]
          }));
        }
        
        if (stat.packetsLost && stat.packetsLost > 0) {
          setQualityMetrics(prev => ({
            ...prev,
            packetLossEvents: prev.packetLossEvents + 1
          }));
        }
      });
    }, 10000); // Every 10 seconds

    return () => {
      if (qualityMonitorInterval.current) {
        clearInterval(qualityMonitorInterval.current);
      }
    };
  }, [roomRef.current]);

  // Save session function
  const saveSession = async (retryCount = 0): Promise<boolean> => {
    if (sessionSaved.current) {
      console.log('Session already saved');
      return true;
    }

    const sessionEndTime = new Date();
    const durationSeconds = Math.floor(
      (sessionEndTime.getTime() - sessionStartTime.getTime()) / 1000
    );

    // Calculate average quality metrics
    const avgBitrate = qualityMetrics.bitrateReadings.length > 0
      ? qualityMetrics.bitrateReadings.reduce((a, b) => a + b, 0) / qualityMetrics.bitrateReadings.length
      : 0;
      
    const avgFps = qualityMetrics.fpsReadings.length > 0
      ? qualityMetrics.fpsReadings.reduce((a, b) => a + b, 0) / qualityMetrics.fpsReadings.length
      : 0;
      
    const totalReadings = qualityMetrics.bitrateReadings.length;
    const packetLossPercentage = totalReadings > 0
      ? (qualityMetrics.packetLossEvents / totalReadings) * 100
      : 0;

    // Construct session payload
    const sessionPayload = {
      session_id: sessionId,
      counselor_category: category,
      mode: 'video',
      start_time: sessionStartTime.toISOString(),
      end_time: sessionEndTime.toISOString(),
      duration_seconds: durationSeconds,
      transcript: transcript.map(msg => ({
        speaker: msg.speaker,
        text: msg.text,
        timestamp: msg.timestamp.toISOString()
      })),
      quality_metrics: {
        average_bitrate: avgBitrate.toFixed(2),
        average_fps: avgFps.toFixed(2),
        packet_loss_percentage: packetLossPercentage.toFixed(2),
        connection_quality_average: calculateConnectionQualityAverage(qualityMetrics.connectionQualityReadings),
        total_readings: totalReadings
      }
    };

    try {
      const response = await fetch('/api/v1/sessions/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(sessionPayload)
      });

      if (!response.ok) {
        throw new Error(`Failed to save session: ${response.statusText}`);
      }

      sessionSaved.current = true;
      
      toast({
        title: "Session Saved",
        description: `Your video session (${durationSeconds}s) has been saved to your history.`,
      });
      
      return true;

    } catch (error) {
      console.error('Error saving session:', error);

      // Retry logic with exponential backoff
      if (retryCount < 3) {
        const backoffDelay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
        console.log(`Retrying save in ${backoffDelay}ms (attempt ${retryCount + 1}/3)`);
        
        await new Promise(resolve => setTimeout(resolve, backoffDelay));
        return saveSession(retryCount + 1);
      }

      // All retries failed
      toast({
        title: "Failed to Save Session",
        description: "Your session data couldn't be saved. Please contact support.",
        variant: "destructive"
      });
      
      return false;
    }
  };

  // Helper: Calculate connection quality average
  const calculateConnectionQualityAverage = (readings: string[]): string => {
    if (readings.length === 0) return 'unknown';
    
    const qualityScores: Record<string, number> = {
      'excellent': 4,
      'good': 3,
      'fair': 2,
      'poor': 1
    };
    
    const totalScore = readings.reduce((sum, quality) => {
      return sum + (qualityScores[quality] || 0);
    }, 0);
    
    const avgScore = totalScore / readings.length;
    
    if (avgScore >= 3.5) return 'excellent';
    if (avgScore >= 2.5) return 'good';
    if (avgScore >= 1.5) return 'fair';
    return 'poor';
  };

  // Track connection quality changes
  useEffect(() => {
    if (!roomRef.current) return;

    const handleConnectionQuality = (quality: string) => {
      setQualityMetrics(prev => ({
        ...prev,
        connectionQualityReadings: [...prev.connectionQualityReadings, quality]
      }));
    };

    roomRef.current.on(RoomEvent.ConnectionQualityChanged, handleConnectionQuality);

    return () => {
      roomRef.current?.off(RoomEvent.ConnectionQualityChanged, handleConnectionQuality);
    };
  }, [roomRef.current]);

  // Handle end session
  const handleEndSession = async () => {
    // Save session first
    await saveSession();
    
    // Disconnect
    if (roomRef.current) {
      roomRef.current.disconnect();
    }
    
    // Navigate to dashboard
    router.push('/dashboard');
  };

  // Handle connection drop (auto-save)
  useEffect(() => {
    if (!roomRef.current) return;

    const handleDisconnected = async () => {
      console.log('Connection dropped, auto-saving session...');
      await saveSession();
    };

    roomRef.current.on(RoomEvent.Disconnected, handleDisconnected);

    return () => {
      roomRef.current?.off(RoomEvent.Disconnected, handleDisconnected);
    };
  }, [roomRef.current, transcript, qualityMetrics]);

  // Handle page unload (save session)
  useEffect(() => {
    const handleBeforeUnload = async (e: BeforeUnloadEvent) => {
      if (!sessionSaved.current) {
        e.preventDefault();
        e.returnValue = '';
        await saveSession();
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [transcript, qualityMetrics]);

  // ... rest of component (video rendering, controls, etc.)

  return (
    <div className="flex flex-col h-screen bg-black">
      {/* Video UI from Story 4.6 */}
      {/* ... */}
    </div>
  );
}

export default function VideoSessionPage() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <VideoSessionContent />
    </Suspense>
  );
}
```

### Backend Session Save Endpoint (Reused from Story 3.7)

**app/routers/sessions.py:**
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.models import User, Session
from app.auth import get_current_user
from pydantic import BaseModel
from typing import List, Dict, Any
from datetime import datetime
import uuid

router = APIRouter(prefix="/sessions", tags=["sessions"])

class TranscriptMessage(BaseModel):
    speaker: str  # 'user' or 'counselor'
    text: str
    timestamp: str

class SaveSessionRequest(BaseModel):
    session_id: str
    counselor_category: str
    mode: str  # 'voice' or 'video'
    start_time: str
    end_time: str
    duration_seconds: int
    transcript: List[TranscriptMessage]
    quality_metrics: Dict[str, Any]

@router.post("/save")
async def save_session(
    request: SaveSessionRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Save a voice or video session to the database.
    
    Supports both voice (Story 3.7) and video (Story 4.7) sessions.
    Mode field distinguishes between the two.
    """
    try:
        # Parse timestamps
        start_time = datetime.fromisoformat(request.start_time.replace('Z', '+00:00'))
        end_time = datetime.fromisoformat(request.end_time.replace('Z', '+00:00'))
        
        # Create session record
        session = Session(
            session_id=uuid.UUID(request.session_id),
            user_id=current_user.user_id,
            counselor_category=uuid.UUID(request.counselor_category),
            mode=request.mode,
            start_time=start_time,
            end_time=end_time,
            duration_seconds=request.duration_seconds,
            transcript=[msg.dict() for msg in request.transcript],
            quality_metrics=request.quality_metrics
        )
        
        db.add(session)
        await db.commit()
        await db.refresh(session)
        
        return {
            "message": "Session saved successfully",
            "session_id": str(session.session_id),
            "mode": session.mode
        }
        
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to save session: {str(e)}")
```

### Updated Session History Page

**app/session-history/page.tsx (updated from Story 3.7):**
```typescript
import { Video, Phone } from 'lucide-react';

interface Session {
  session_id: string;
  mode: 'voice' | 'video';
  counselor_category: string;
  start_time: string;
  duration_seconds: number;
  quality_metrics: any;
}

function SessionCard({ session }: { session: Session }) {
  const ModeIcon = session.mode === 'video' ? Video : Phone;
  const modeColor = session.mode === 'video' ? 'text-purple-600' : 'text-blue-600';
  
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center gap-2">
          <ModeIcon className={cn("h-5 w-5", modeColor)} />
          <CardTitle className="capitalize">{session.mode} Session</CardTitle>
        </div>
        <CardDescription>{session.counselor_category}</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-2 text-sm">
          <div>
            <span className="font-semibold">Date:</span>{' '}
            {new Date(session.start_time).toLocaleString()}
          </div>
          <div>
            <span className="font-semibold">Duration:</span>{' '}
            {Math.floor(session.duration_seconds / 60)}m {session.duration_seconds % 60}s
          </div>
          {session.mode === 'video' && session.quality_metrics && (
            <div>
              <span className="font-semibold">Video Quality:</span>{' '}
              {session.quality_metrics.average_fps} fps, {' '}
              {session.quality_metrics.average_bitrate} kbps
            </div>
          )}
        </div>
        <Button className="mt-4 w-full" variant="outline">
          View Transcript
        </Button>
      </CardContent>
    </Card>
  );
}
```

### Source Tree Updates

```
packages/frontend/
├── app/
│   ├── video-session/
│   │   └── page.tsx              # Updated with session logging
│   └── session-history/
│       └── page.tsx              # Updated to show video sessions
└── lib/
    └── api/
        └── sessions.ts           # Session save utilities

packages/backend/
└── app/
    └── routers/
        └── sessions.py           # Session save endpoint (reused)
```

---

## Testing

### Testing Requirements:

1. **Transcript Capture Test:**
   ```typescript
   import { render, waitFor } from '@testing-library/react';
   import VideoSessionPage from '@/app/video-session/page';

   describe('Video Session Transcript', () => {
     it('captures transcript messages during session', async () => {
       const { container } = render(<VideoSessionPage />);
       
       // Simulate transcript messages
       act(() => {
         fireEvent(window, new CustomEvent('transcript', {
           detail: {
             speaker: 'user',
             text: 'I need help',
             timestamp: new Date()
           }
         }));
       });
       
       await waitFor(() => {
         expect(screen.getByText('I need help')).toBeInTheDocument();
       });
     });
   });
   ```

2. **Quality Metrics Tracking Test:**
   ```typescript
   it('tracks video quality metrics', async () => {
     const { container } = render(<VideoSessionPage />);
     
     // Simulate quality readings
     // (Would mock LiveKit stats in real test)
     
     await waitFor(() => {
       // Verify metrics are being tracked
     });
   });
   ```

3. **Session Save Test:**
   ```typescript
   it('saves session on end', async () => {
     global.fetch = vi.fn().mockResolvedValue({
       ok: true,
       json: async () => ({ message: 'Session saved' })
     });
     
     render(<VideoSessionPage />);
     
     const endButton = screen.getByText(/end session/i);
     fireEvent.click(endButton);
     
     const confirmButton = screen.getByText(/end session/i);  // In dialog
     fireEvent.click(confirmButton);
     
     await waitFor(() => {
       expect(global.fetch).toHaveBeenCalledWith(
         '/api/v1/sessions/save',
         expect.objectContaining({
           method: 'POST',
           body: expect.stringContaining('"mode":"video"')
         })
       );
     });
   });
   ```

4. **Retry Logic Test:**
   ```typescript
   it('retries session save on failure', async () => {
     let callCount = 0;
     global.fetch = vi.fn().mockImplementation(() => {
       callCount++;
       if (callCount < 3) {
         return Promise.resolve({ ok: false });
       }
       return Promise.resolve({
         ok: true,
         json: async () => ({ message: 'Session saved' })
       });
     });
     
     render(<VideoSessionPage />);
     
     // Trigger save
     // ...
     
     await waitFor(() => {
       expect(callCount).toBe(3);  // 1 initial + 2 retries
     }, { timeout: 10000 });
   });
   ```

5. **Manual Testing Checklist:**
   - [ ] Transcript captured during video session
   - [ ] Video quality metrics tracked (bitrate, fps)
   - [ ] Session saved when clicking "End Session"
   - [ ] Session saved when connection drops
   - [ ] Session saved when closing browser tab
   - [ ] Success toast shown after save
   - [ ] Retry logic works on API failure
   - [ ] Error toast shown after 3 failed retries
   - [ ] Video session appears in session history
   - [ ] Video icon distinguishes video from voice sessions
   - [ ] Session detail shows video quality metrics
   - [ ] Session duration calculated correctly
   - [ ] Transcript viewable from session history
   - [ ] Backend endpoint accepts mode="video"
   - [ ] Database stores video session correctly

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
