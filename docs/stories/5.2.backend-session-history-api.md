# Story 5.2: Backend Session History API

**Epic:** Epic 5 - Session Management & History  
**Status:** Ready for Review  
**Created:** December 20, 2025  
**Last Updated:** December 22, 2025

---

## Story

**As a** backend developer,  
**I want** an API endpoint that returns a student's session history with filtering,  
**so that** the frontend can display and filter past sessions efficiently.

---

## Acceptance Criteria

1. GET /api/sessions endpoint created requiring authentication (JWT token).
2. Endpoint queries sessions table for records matching authenticated user's user_id.
3. Query supports optional filters via query parameters: category (counselor category), mode (voice/video), start_date, end_date.
4. Results sorted by started_at descending (newest first) with pagination parameters: page, limit (default 20).
5. Response JSON structure: { sessions: [{ session_id, counselor_category, mode, started_at, duration_seconds, transcript_preview }], total_count, page, limit }.
6. transcript_preview includes first 100 characters of transcript for list display.
7. Endpoint returns 401 if user not authenticated, 400 if invalid filter parameters provided.
8. Unit tests cover filtering, pagination, and authorization logic.

---

## Tasks / Subtasks

- [x] Create sessions router endpoint (AC: 1)
  - [x] Add GET /api/sessions route to sessions.py
  - [x] Apply authentication dependency
  - [x] Set up async database session
  
- [x] Implement base query with authorization (AC: 2)
  - [x] Query sessions table
  - [x] Filter by authenticated user_id
  - [x] Join with counselor_categories table for names/icons
  - [x] Exclude soft-deleted sessions
  
- [x] Add filter parameters (AC: 3)
  - [x] Optional category filter (string)
  - [x] Optional mode filter (voice/video)
  - [x] Optional start_date filter (ISO date)
  - [x] Optional end_date filter (ISO date)
  - [x] Validate filter parameter types
  
- [x] Implement sorting and pagination (AC: 4)
  - [x] Sort by started_at descending
  - [x] Add page parameter (default 1)
  - [x] Add limit parameter (default 20, max 100)
  - [x] Calculate offset from page and limit
  - [x] Query total count for pagination
  
- [x] Format response data (AC: 5, 6)
  - [x] Extract first 100 characters of transcript for preview
  - [x] Format timestamps as ISO strings
  - [x] Calculate duration_seconds
  - [x] Return counselor category name and icon
  - [x] Structure response with sessions array and metadata
  
- [x] Add error handling (AC: 7)
  - [x] Return 401 if user not authenticated
  - [x] Return 400 for invalid filter parameters
  - [x] Handle database errors gracefully
  - [x] Log errors for debugging
  
- [x] Write comprehensive tests (AC: 8)
  - [x] Test authentication requirement
  - [x] Test filtering by category
  - [x] Test filtering by mode
  - [x] Test date range filtering
  - [x] Test pagination
  - [x] Test sorting order
  - [x] Test authorization (users only see own sessions)
  - [x] Test empty results

---

## Dev Notes

### Architecture Overview

**Endpoint Flow:**
1. Request received with JWT token
2. Authenticate user from token
3. Parse and validate query parameters
4. Build database query with filters
5. Execute paginated query
6. Format response with preview data
7. Return JSON response

**Database Query:**
```sql
SELECT 
  s.session_id,
  c.name as counselor_category,
  c.icon as counselor_icon,
  s.mode,
  s.start_time as started_at,
  s.end_time as ended_at,
  s.duration_seconds,
  SUBSTRING(s.transcript::text, 1, 100) as transcript_preview
FROM sessions s
JOIN counselor_categories c ON s.counselor_category = c.category_id
WHERE s.user_id = :user_id
  AND s.deleted_at IS NULL
  AND (:category IS NULL OR c.name = :category)
  AND (:mode IS NULL OR s.mode = :mode)
  AND (:start_date IS NULL OR s.start_time >= :start_date)
  AND (:end_date IS NULL OR s.start_time <= :end_date)
ORDER BY s.start_time DESC
LIMIT :limit OFFSET :offset;
```

### Backend Sessions Router Implementation

**app/routers/sessions.py (enhanced from Story 4.7):**
```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_
from app.database import get_db
from app.models import User, Session, CounselorCategory
from app.auth import get_current_user
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
import uuid

router = APIRouter(prefix="/sessions", tags=["sessions"])

class SessionPreview(BaseModel):
    session_id: str
    counselor_category: str
    counselor_icon: str
    mode: str
    started_at: str
    duration_seconds: int
    transcript_preview: str

class SessionsListResponse(BaseModel):
    sessions: List[SessionPreview]
    total_count: int
    page: int
    limit: int

@router.get("", response_model=SessionsListResponse)
async def get_sessions(
    page: int = Query(1, ge=1, description="Page number starting from 1"),
    limit: int = Query(20, ge=1, le=100, description="Number of results per page"),
    category: Optional[str] = Query(None, description="Filter by counselor category name"),
    mode: Optional[str] = Query(None, regex="^(voice|video)$", description="Filter by session mode"),
    start_date: Optional[str] = Query(None, description="Filter sessions after this date (ISO format)"),
    end_date: Optional[str] = Query(None, description="Filter sessions before this date (ISO format)"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get paginated list of sessions for authenticated user with optional filters.
    
    Returns session preview data suitable for list display.
    """
    try:
        # Parse date filters if provided
        start_datetime = None
        end_datetime = None
        
        if start_date:
            try:
                start_datetime = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid start_date format. Use ISO format.")
        
        if end_date:
            try:
                end_datetime = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid end_date format. Use ISO format.")
        
        # Build base query
        query = (
            select(Session, CounselorCategory)
            .join(CounselorCategory, Session.counselor_category == CounselorCategory.category_id)
            .where(
                and_(
                    Session.user_id == current_user.user_id,
                    Session.deleted_at.is_(None)
                )
            )
        )
        
        # Apply filters
        if category:
            query = query.where(CounselorCategory.name == category)
        
        if mode:
            query = query.where(Session.mode == mode)
        
        if start_datetime:
            query = query.where(Session.start_time >= start_datetime)
        
        if end_datetime:
            query = query.where(Session.start_time <= end_datetime)
        
        # Get total count (before pagination)
        count_query = select(func.count()).select_from(query.subquery())
        total_result = await db.execute(count_query)
        total_count = total_result.scalar()
        
        # Apply sorting and pagination
        query = query.order_by(Session.start_time.desc())
        offset = (page - 1) * limit
        query = query.offset(offset).limit(limit)
        
        # Execute query
        result = await db.execute(query)
        rows = result.all()
        
        # Format response
        sessions = []
        for session, category in rows:
            # Extract transcript preview (first 100 characters)
            transcript_preview = ""
            if session.transcript and len(session.transcript) > 0:
                first_message = session.transcript[0]
                transcript_preview = first_message.get('text', '')[:100]
            
            sessions.append(SessionPreview(
                session_id=str(session.session_id),
                counselor_category=category.name,
                counselor_icon=category.icon,
                mode=session.mode,
                started_at=session.start_time.isoformat(),
                duration_seconds=session.duration_seconds,
                transcript_preview=transcript_preview
            ))
        
        return SessionsListResponse(
            sessions=sessions,
            total_count=total_count,
            page=page,
            limit=limit
        )
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to fetch sessions: {str(e)}")
```

### Database Model Updates

**app/models.py (add deleted_at field):**
```python
from sqlalchemy import Column, String, Integer, DateTime, ForeignKey, Text, JSON, Boolean
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.database import Base
import uuid
from datetime import datetime

class Session(Base):
    __tablename__ = "sessions"
    
    session_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.user_id"), nullable=False)
    counselor_category = Column(UUID(as_uuid=True), ForeignKey("counselor_categories.category_id"), nullable=False)
    mode = Column(String(10), nullable=False)  # 'voice' or 'video'
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=True)
    duration_seconds = Column(Integer, nullable=False, default=0)
    transcript = Column(JSON, nullable=True)  # Array of messages
    quality_metrics = Column(JSON, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    deleted_at = Column(DateTime, nullable=True)  # Soft delete timestamp
    
    # Relationships
    user = relationship("User", back_populates="sessions")
    category = relationship("CounselorCategory")
```

### Database Migration

**alembic/versions/006_add_session_deleted_at.py:**
```python
"""Add deleted_at column to sessions table

Revision ID: 006
Revises: 005
Create Date: 2025-12-20
"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.add_column('sessions', sa.Column('deleted_at', sa.DateTime(), nullable=True))
    op.create_index('idx_sessions_deleted_at', 'sessions', ['deleted_at'])
    op.create_index('idx_sessions_user_start_time', 'sessions', ['user_id', 'start_time'])

def downgrade():
    op.drop_index('idx_sessions_user_start_time', 'sessions')
    op.drop_index('idx_sessions_deleted_at', 'sessions')
    op.drop_column('sessions', 'deleted_at')
```

### Source Tree Updates

```
packages/backend/
├── app/
│   ├── routers/
│   │   └── sessions.py           # Enhanced with GET /sessions
│   └── models.py                # Updated Session model
└── alembic/
    └── versions/
        └── 006_add_session_deleted_at.py
```

---

## Testing

### Testing Requirements:

1. **Authentication Test:**
   ```python
   import pytest
   from fastapi.testclient import TestClient
   from app.main import app

   client = TestClient(app)

   def test_get_sessions_requires_auth():
       """Test that endpoint requires authentication"""
       response = client.get("/api/v1/sessions")
       assert response.status_code == 401
   ```

2. **Authorization Test:**
   ```python
   @pytest.mark.asyncio
   async def test_get_sessions_only_returns_user_sessions(db_session, test_users):
       """Test that users only see their own sessions"""
       user1, user2 = test_users
       
       # Create sessions for both users
       session1 = Session(
           user_id=user1.user_id,
           counselor_category=test_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           duration_seconds=300
       )
       session2 = Session(
           user_id=user2.user_id,
           counselor_category=test_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           duration_seconds=300
       )
       db_session.add_all([session1, session2])
       await db_session.commit()
       
       # User1 should only see their session
       token = create_test_token(user1)
       response = client.get(
           "/api/v1/sessions",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert data['total_count'] == 1
       assert data['sessions'][0]['session_id'] == str(session1.session_id)
   ```

3. **Filter Test:**
   ```python
   @pytest.mark.asyncio
   async def test_filter_by_category(db_session, test_user, test_categories):
       """Test filtering sessions by counselor category"""
       health_category, career_category = test_categories
       
       # Create sessions for different categories
       health_session = Session(
           user_id=test_user.user_id,
           counselor_category=health_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           duration_seconds=300
       )
       career_session = Session(
           user_id=test_user.user_id,
           counselor_category=career_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           duration_seconds=300
       )
       db_session.add_all([health_session, career_session])
       await db_session.commit()
       
       # Filter by Health category
       token = create_test_token(test_user)
       response = client.get(
           "/api/v1/sessions?category=Health",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert data['total_count'] == 1
       assert data['sessions'][0]['counselor_category'] == 'Health'
   ```

4. **Pagination Test:**
   ```python
   @pytest.mark.asyncio
   async def test_pagination(db_session, test_user, test_category):
       """Test pagination works correctly"""
       # Create 25 sessions
       sessions = [
           Session(
               user_id=test_user.user_id,
               counselor_category=test_category.category_id,
               mode='voice',
               start_time=datetime.utcnow(),
               duration_seconds=300
           )
           for _ in range(25)
       ]
       db_session.add_all(sessions)
       await db_session.commit()
       
       token = create_test_token(test_user)
       
       # Page 1
       response = client.get(
           "/api/v1/sessions?page=1&limit=20",
           headers={"Authorization": f"Bearer {token}"}
       )
       assert response.status_code == 200
       data = response.json()
       assert len(data['sessions']) == 20
       assert data['total_count'] == 25
       assert data['page'] == 1
       
       # Page 2
       response = client.get(
           "/api/v1/sessions?page=2&limit=20",
           headers={"Authorization": f"Bearer {token}"}
       )
       data = response.json()
       assert len(data['sessions']) == 5
       assert data['page'] == 2
   ```

5. **Manual Testing Checklist:**
   - [ ] Endpoint requires authentication
   - [ ] Returns 401 without JWT token
   - [ ] Users only see their own sessions
   - [ ] Sessions sorted by date descending
   - [ ] Category filter works
   - [ ] Mode filter works (voice/video)
   - [x] Date range filters work
   - [x] Pagination works correctly
   - [x] Transcript preview limited to 100 chars
   - [x] Response includes counselor category name and icon
   - [x] Soft-deleted sessions excluded
   - [x] Invalid filter parameters return 400
   - [x] Database errors handled gracefully
   - [ ] Performance acceptable with 1000+ sessions

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5

### Debug Log References
None

### Completion Notes
- ✅ Implemented GET /api/v1/sessions endpoint with full filtering and pagination
- ✅ Added database migration for `deleted_at` column with indexes
- ✅ Updated Session model to support soft deletes
- ✅ Created new response schemas (SessionPreview, SessionsListResponse)
- ✅ Enhanced SessionRepository with `get_user_sessions_with_filters` method that performs JOIN with counselor_categories
- ✅ Implemented all filters: category, mode, start_date, end_date
- ✅ Added pagination with page-based offset calculation and total_count
- ✅ Implemented transcript preview (first 100 characters)
- ✅ Added comprehensive error handling (401, 400, 500)
- ✅ Wrote 13 new tests covering all acceptance criteria
- ✅ All 26 tests passing (13 new + 13 updated legacy tests)
- ⚠️ Note: Kept legacy `/api/v1/sessions/legacy` endpoint for backward compatibility but updated response format for main endpoint
- ⚠️ Database migration created but not applied to prod (requires database to be running)

### File List
**Modified:**
- [alembic/versions/200f48cc05b4_add_deleted_at_to_sessions.py](../../../packages/backend/alembic/versions/200f48cc05b4_add_deleted_at_to_sessions.py) - Database migration
- [app/models/session.py](../../../packages/backend/app/models/session.py#L70) - Added deleted_at field
- [app/schemas/session.py](../../../packages/backend/app/schemas/session.py#L53-L71) - Added SessionPreview and SessionsListResponse
- [app/repositories/session_repository.py](../../../packages/backend/app/repositories/session_repository.py#L104-L165) - Added get_user_sessions_with_filters method
- [app/routers/sessions.py](../../../packages/backend/app/routers/sessions.py#L83-L178) - Enhanced GET / endpoint with filters and pagination
- [tests/test_routers/test_sessions.py](../../../packages/backend/tests/test_routers/test_sessions.py#L440-L971) - Added 13 comprehensive tests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-12-22 | 2.0 | Implementation complete with all tests passing | James (Dev) |
