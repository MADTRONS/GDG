# Story 5.5: Backend Session Detail API

**Epic:** Epic 5 - Session Management & History  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** backend developer,  
**I want** an API endpoint that returns complete session details including full transcript,  
**so that** students can view their past conversations.

---

## Acceptance Criteria

1. GET /api/sessions/:sessionId endpoint created requiring authentication.
2. Endpoint queries sessions table for record matching session_id and authenticated user_id.
3. Response includes: session_id, counselor_category, mode, started_at, ended_at, duration_seconds, full transcript (JSON array of messages).
4. Endpoint returns 404 if session_id not found, 403 if session belongs to different user.
5. Transcript deserialized from database TEXT field into JSON array structure: [{ timestamp: ISO string, speaker: "user"|"counselor", text: string }].
6. Unit tests verify authorization logic and data structure.

---

## Tasks / Subtasks

- [x] Create session detail endpoint (AC: 1)
  - [x] Add GET /api/sessions/{session_id} route
  - [x] Apply authentication dependency
  - [x] Parse sessionId from path parameter
  
- [x] Implement query with authorization (AC: 2)
  - [x] Query sessions table by session_id
  - [x] Filter by authenticated user_id
  - [x] Join with counselor_categories table
  - [x] Exclude soft-deleted sessions
  
- [x] Format response data (AC: 3, 5)
  - [x] Include all required fields
  - [x] Return full transcript array
  - [x] Format timestamps as ISO strings
  - [x] Include counselor category name and icon
  - [x] Include quality metrics if available
  
- [x] Add error handling (AC: 4)
  - [x] Return 404 if session not found
  - [x] Return 403 if user doesn't own session
  - [x] Handle database errors gracefully
  - [x] Log errors for debugging
  
- [x] Write comprehensive tests (AC: 6)
  - [x] Test authentication requirement
  - [x] Test authorization (403 for wrong user)
  - [x] Test 404 for non-existent session
  - [x] Test successful response structure
  - [x] Test transcript deserialization
  - [x] Test soft-deleted session exclusion

---

## Dev Notes

### Architecture Overview

**Endpoint Flow:**
1. Request received with JWT token and sessionId
2. Authenticate user from token
3. Query database for session by ID
4. Verify user owns session
5. Format response with full transcript
6. Return JSON response

### Backend Session Detail Endpoint

**app/routers/sessions.py (add to existing file):**
```python
from fastapi import APIRouter, Depends, HTTPException, Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from app.database import get_db
from app.models import User, Session, CounselorCategory
from app.auth import get_current_user
from pydantic import BaseModel
from typing import List, Optional, Any
from datetime import datetime
import uuid

router = APIRouter(prefix="/sessions", tags=["sessions"])

class TranscriptMessage(BaseModel):
    timestamp: str
    speaker: str  # 'user' or 'counselor'
    text: str

class SessionDetailResponse(BaseModel):
    session_id: str
    counselor_category: str
    counselor_icon: str
    mode: str
    started_at: str
    ended_at: str
    duration_seconds: int
    transcript: List[TranscriptMessage]
    quality_metrics: Optional[dict] = None

@router.get("/{session_id}", response_model=SessionDetailResponse)
async def get_session_detail(
    session_id: str = Path(..., description="UUID of the session"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get complete session details including full transcript.
    
    Only the session owner can access this endpoint.
    """
    try:
        # Validate UUID format
        try:
            session_uuid = uuid.UUID(session_id)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid session ID format")
        
        # Query session with counselor category
        query = (
            select(Session, CounselorCategory)
            .join(CounselorCategory, Session.counselor_category == CounselorCategory.category_id)
            .where(
                and_(
                    Session.session_id == session_uuid,
                    Session.deleted_at.is_(None)
                )
            )
        )
        
        result = await db.execute(query)
        row = result.first()
        
        # Check if session exists
        if not row:
            raise HTTPException(status_code=404, detail="Session not found")
        
        session, category = row
        
        # Check authorization - user must own the session
        if session.user_id != current_user.user_id:
            raise HTTPException(
                status_code=403,
                detail="You do not have permission to access this session"
            )
        
        # Format transcript
        transcript_messages = []
        if session.transcript:
            for msg in session.transcript:
                transcript_messages.append(TranscriptMessage(
                    timestamp=msg.get('timestamp', ''),
                    speaker=msg.get('speaker', 'unknown'),
                    text=msg.get('text', '')
                ))
        
        # Build response
        return SessionDetailResponse(
            session_id=str(session.session_id),
            counselor_category=category.name,
            counselor_icon=category.icon,
            mode=session.mode,
            started_at=session.start_time.isoformat(),
            ended_at=session.end_time.isoformat() if session.end_time else session.start_time.isoformat(),
            duration_seconds=session.duration_seconds,
            transcript=transcript_messages,
            quality_metrics=session.quality_metrics
        )
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to fetch session details: {str(e)}")
```

### Source Tree Updates

```
packages/backend/
â””â”€â”€ app/
    â””â”€â”€ routers/
        â””â”€â”€ sessions.py           # Add GET /{session_id} endpoint
```

---

## Testing

### Testing Requirements:

1. **Authentication Test:**
   ```python
   def test_get_session_detail_requires_auth():
       """Test that endpoint requires authentication"""
       response = client.get("/api/v1/sessions/123e4567-e89b-12d3-a456-426614174000")
       assert response.status_code == 401
   ```

2. **Authorization Test:**
   ```python
   @pytest.mark.asyncio
   async def test_get_session_detail_authorization(db_session, test_users, test_category):
       """Test that users can only access their own sessions"""
       user1, user2 = test_users
       
       # Create session for user1
       session = Session(
           user_id=user1.user_id,
           counselor_category=test_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           end_time=datetime.utcnow(),
           duration_seconds=300,
           transcript=[
               {'timestamp': '2025-12-20T10:00:00Z', 'speaker': 'user', 'text': 'Hello'}
           ]
       )
       db_session.add(session)
       await db_session.commit()
       await db_session.refresh(session)
       
       # User2 tries to access user1's session - should get 403
       token = create_test_token(user2)
       response = client.get(
           f"/api/v1/sessions/{session.session_id}",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 403
       assert 'permission' in response.json()['detail'].lower()
   ```

3. **Success Test:**
   ```python
   @pytest.mark.asyncio
   async def test_get_session_detail_success(db_session, test_user, test_category):
       """Test successful session detail retrieval"""
       # Create session
       transcript_data = [
           {'timestamp': '2025-12-20T10:00:00Z', 'speaker': 'user', 'text': 'I need help'},
           {'timestamp': '2025-12-20T10:00:05Z', 'speaker': 'counselor', 'text': 'How can I assist you?'}
       ]
       
       session = Session(
           user_id=test_user.user_id,
           counselor_category=test_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           end_time=datetime.utcnow(),
           duration_seconds=300,
           transcript=transcript_data,
           quality_metrics={'connection_quality_average': 'good'}
       )
       db_session.add(session)
       await db_session.commit()
       await db_session.refresh(session)
       
       # Fetch session
       token = create_test_token(test_user)
       response = client.get(
           f"/api/v1/sessions/{session.session_id}",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert data['session_id'] == str(session.session_id)
       assert data['counselor_category'] == test_category.name
       assert data['mode'] == 'voice'
       assert data['duration_seconds'] == 300
       assert len(data['transcript']) == 2
       assert data['transcript'][0]['text'] == 'I need help'
       assert data['quality_metrics']['connection_quality_average'] == 'good'
   ```

4. **Not Found Test:**
   ```python
   def test_get_session_detail_not_found(test_user):
       """Test 404 for non-existent session"""
       token = create_test_token(test_user)
       fake_uuid = str(uuid.uuid4())
       
       response = client.get(
           f"/api/v1/sessions/{fake_uuid}",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 404
   ```

5. **Manual Testing Checklist:**
   - [x] Endpoint requires authentication
   - [x] Returns 401 without JWT token
   - [x] Users can only access their own sessions
   - [x] Returns 403 for unauthorized access
   - [x] Returns 404 for non-existent session
   - [x] Returns complete session data
   - [x] Full transcript included in response
   - [x] Transcript messages properly formatted
   - [x] Timestamps in ISO format
   - [x] Quality metrics included if available
   - [x] Counselor category name and icon included
   - [x] Soft-deleted sessions return 404
   - [x] Invalid UUID format returns 422
   - [x] Database errors handled gracefully

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-12-22 | 2.0 | Implementation complete | James (Dev) |

---

## Dev Agent Record

### Status
Ready for Review

### Agent Model Used
Claude Sonnet 4.5

### Completion Notes

Successfully implemented GET /api/v1/sessions/{session_id} endpoint with full requirements:

**Key Accomplishments:**
- Enhanced existing endpoint to include counselor category JOIN for icon/name
- Added quality_metrics field to Session model and schema
- Created database migration for quality_metrics column (JSONB)
- Implemented comprehensive authorization (user ownership validation)
- Proper soft-delete handling (excludes deleted_at sessions)
- Full transcript deserialization from JSONB
- ISO timestamp formatting for all datetime fields
- Comprehensive test coverage: 8 new tests (all passing)
- Updated 2 existing tests to accommodate counselor category requirement

**Technical Implementation:**
- Updated SessionDetail schema to include counselor_icon and quality_metrics
- Modified endpoint to perform INNER JOIN between sessions and counselor_categories tables
- Enhanced error handling for 404 (not found), 403 (unauthorized), 422 (invalid UUID)
- Maintained consistency with existing session endpoints

**Testing:**
- 8 comprehensive tests in test_session_detail.py (100% pass rate)
- Tests cover: authentication, authorization, not found, soft-delete, success cases, quality metrics, empty transcript, invalid UUID
- Updated 2 existing tests in test_routers/test_sessions.py to create counselor categories
- All backend tests passing (149 tests, excluding unrelated pipecat failures)

### Debug Log References
No debugging required - implementation completed on first pass with minor import fix

### File List

**Modified:**
- [packages/backend/app/routers/sessions.py](../../../packages/backend/app/routers/sessions.py) - Enhanced GET /{session_id} endpoint with counselor category JOIN
- [packages/backend/app/models/session.py](../../../packages/backend/app/models/session.py) - Added quality_metrics field
- [packages/backend/app/schemas/session.py](../../../packages/backend/app/schemas/session.py) - Added counselor_icon and quality_metrics to SessionDetail
- [packages/backend/tests/test_routers/test_sessions.py](../../../packages/backend/tests/test_routers/test_sessions.py) - Updated existing tests to create counselor categories

**Created:**
- [packages/backend/alembic/versions/672c05922909_add_quality_metrics_to_sessions.py](../../../packages/backend/alembic/versions/672c05922909_add_quality_metrics_to_sessions.py) - Migration for quality_metrics column
- [packages/backend/tests/test_session_detail.py](../../../packages/backend/tests/test_session_detail.py) - Comprehensive test suite for session detail endpoint

### Change Log

- Enhanced SessionDetail response schema with counselor_icon and quality_metrics fields
- Implemented database JOIN with counselor_categories table for complete session data
- Added quality_metrics JSONB column to sessions table via migration
- Created comprehensive test suite covering all acceptance criteria
- Updated existing tests to support counselor category requirement

---

## QA Results

### Quality Gate Decision
**Status:** âœ… **PASS**  
**Quality Score:** 92/100  
**Reviewed By:** Quinn (Test Architect)  
**Date:** December 22, 2025  
**Gate File:** [5.5-backend-session-detail-api.yml](../qa/gates/5.5-backend-session-detail-api.yml)

### Executive Summary
Excellent implementation with comprehensive test coverage, proper authorization, and clean architecture. All 6 acceptance criteria fully validated with 100% test pass rate (8/8 tests). **APPROVED for production deployment.**

### Acceptance Criteria Validation

| AC | Requirement | Status | Test Coverage | Notes |
|----|-------------|--------|---------------|-------|
| 1 | GET endpoint with authentication | âœ… PASS | `test_get_session_detail_requires_authentication` | Returns 401 without JWT token |
| 2 | Query by session_id and user_id | âœ… PASS | `test_get_session_detail_authorization_wrong_user`<br>`test_get_session_detail_success_with_transcript` | Uses INNER JOIN with counselor_categories |
| 3 | Response includes all required fields | âœ… PASS | `test_get_session_detail_success_with_transcript`<br>`test_get_session_detail_with_quality_metrics` | Enhanced with counselor_icon and quality_metrics |
| 4 | Returns 404/403 for errors | âœ… PASS | `test_get_session_detail_not_found`<br>`test_get_session_detail_authorization_wrong_user`<br>`test_get_session_detail_soft_deleted` | Also handles soft-deleted sessions |
| 5 | Transcript deserialization | âœ… PASS | `test_get_session_detail_success_with_transcript`<br>`test_get_session_detail_empty_transcript` | Handles empty transcripts gracefully |
| 6 | Unit tests for authorization | âœ… PASS | All 8 tests in `test_session_detail.py` | 100% pass rate, comprehensive coverage |

**Coverage:** 6/6 acceptance criteria validated (100%)

### Test Architecture Assessment

**Test Quality:** âœ… Excellent

- **Test Count:** 8 comprehensive tests (all passing)
- **Test Level:** Integration tests with real database fixtures (appropriate)
- **Edge Cases:** Empty transcript, invalid UUID, soft-deleted sessions, missing owner
- **Mock Strategy:** Minimal mocking (appropriate for integration tests)
- **Test Maintainability:** Clean fixtures, clear test names, proper async patterns

**Test Coverage Breakdown:**
- âœ… Authentication (401)
- âœ… Authorization - wrong user (403)
- âœ… Not found (404)
- âœ… Soft-deleted sessions (404)
- âœ… Success with full transcript (200)
- âœ… Success with quality metrics (200)
- âœ… Empty transcript edge case (200)
- âœ… Invalid UUID format (422)

### Non-Functional Requirements Validation

| NFR | Status | Assessment |
|-----|--------|------------|
| **Security** | âœ… PASS | Comprehensive JWT authentication and user ownership authorization. No SQL injection risks (SQLAlchemy ORM). Proper 403/404 error differentiation prevents user enumeration. |
| **Performance** | âœ… PASS | Efficient INNER JOIN with indexed UUID lookups. JSONB fields properly handled. Consider pagination if transcripts exceed 1000 messages (future enhancement). |
| **Reliability** | âœ… PASS | Comprehensive error handling (401/403/404/422/500). Soft-delete handling prevents data leaks. Database exceptions caught and logged with stack traces. |
| **Maintainability** | âœ… PASS | Clean code with SQLAlchemy 2.0 type hints. Well-structured tests with clear fixtures. Comprehensive Dev Agent Record documentation. |

### Code Quality Review

**Architecture:** âœ… Excellent
- Repository pattern (SQLAlchemy models)
- Dependency injection (FastAPI Depends)
- Data transfer objects (Pydantic schemas)

**Implementation Highlights:**
- âœ… Proper SQLAlchemy 2.0 async patterns
- âœ… Clean separation of concerns
- âœ… Type hints throughout
- âœ… Efficient database queries with INNER JOIN
- âœ… No code duplication identified
- âœ… Best practices adhered to

### Risk Profile

**Overall Risk:** ðŸŸ¢ LOW

| Severity | Count | Issues |
|----------|-------|--------|
| Critical | 0 | None |
| High | 0 | None |
| Medium | 0 | None |
| Low | 2 | Deprecation warnings (non-blocking) |

**Must-Fix Issues:** None

**Monitor Items:**
1. **MAINT-001** (Low): Pydantic V2 deprecation warnings - address during next maintenance cycle
2. **MAINT-002** (Low): FastAPI Query.regex deprecation - replace with `pattern` when convenient

### Requirements Traceability

**Given-When-Then Mapping:**

**AC1: Authentication Required**
- **Given** unauthenticated request
- **When** GET /api/v1/sessions/{session_id}
- **Then** returns 401
- **Test:** `test_get_session_detail_requires_authentication`

**AC2: Query with Authorization**
- **Given** authenticated user and valid session_id
- **When** user owns the session
- **Then** returns session details with JOIN to counselor_categories
- **Test:** `test_get_session_detail_success_with_transcript`

- **Given** authenticated user and valid session_id
- **When** user does NOT own the session
- **Then** returns 403 Forbidden
- **Test:** `test_get_session_detail_authorization_wrong_user`

**AC3: Response Structure**
- **Given** valid session request
- **When** session exists and user owns it
- **Then** returns session_id, counselor_category, counselor_icon, mode, timestamps, duration, transcript, quality_metrics
- **Test:** `test_get_session_detail_success_with_transcript`, `test_get_session_detail_with_quality_metrics`

**AC4: Error Handling**
- **Given** non-existent session_id
- **When** GET request
- **Then** returns 404
- **Test:** `test_get_session_detail_not_found`

- **Given** soft-deleted session
- **When** GET request
- **Then** returns 404
- **Test:** `test_get_session_detail_soft_deleted`

- **Given** invalid UUID format
- **When** GET request
- **Then** returns 422
- **Test:** `test_get_session_detail_invalid_uuid_format`

**AC5: Transcript Deserialization**
- **Given** session with JSONB transcript
- **When** retrieved
- **Then** deserializes to array of {timestamp, speaker, text}
- **Test:** `test_get_session_detail_success_with_transcript`, `test_get_session_detail_empty_transcript`

**AC6: Unit Tests**
- **Given** authorization logic implementation
- **When** tests executed
- **Then** all authorization scenarios covered
- **Test:** Complete test suite with 8 tests (100% pass)

**Coverage:** âœ… All requirements mapped to implementation and tests

### Technical Debt Identified

| ID | Description | Severity | Effort | Recommendation |
|----|-------------|----------|--------|----------------|
| MAINT-001 | Pydantic class-based config deprecation | Low | Low | Address during next Pydantic upgrade cycle |
| MAINT-002 | FastAPI Query.regex deprecation | Low | Low | Replace with `pattern` in existing endpoints |

**Total Debt:** 2 items (all low priority, non-blocking)

### Testability Evaluation

- **Controllability:** âœ… Excellent (can control all inputs via fixtures)
- **Observability:** âœ… Excellent (clear response structures and error messages)
- **Debuggability:** âœ… Excellent (comprehensive logging with stack traces)

### Standards Compliance

- âœ… **Coding Standards:** Follows FastAPI best practices, SQLAlchemy 2.0 patterns
- âœ… **Project Structure:** Proper file organization, separation of concerns
- âœ… **Testing Strategy:** Comprehensive integration tests with real database

### Decision Rationale

**PASS with commendation** - This implementation demonstrates exceptional quality:

**Strengths:**
- âœ… All 6 acceptance criteria fully validated with comprehensive test coverage
- âœ… 8/8 tests passing (100% success rate) with excellent scenario coverage
- âœ… Proper authentication (JWT) and authorization (user ownership)
- âœ… Clean architecture with SQLAlchemy 2.0 async patterns
- âœ… Enhanced schema beyond original requirements (counselor_icon, quality_metrics)
- âœ… Comprehensive error handling (401/403/404/422/500)
- âœ… Soft-delete handling prevents data leaks
- âœ… Edge cases covered (empty transcript, invalid UUID, soft-deleted)
- âœ… Database migration properly created and documented
- âœ… No security vulnerabilities identified
- âœ… Efficient query design with INNER JOIN
- âœ… Proper type hints and modern Python practices

**Minor Technical Debt (Low Priority):**
- Pydantic V2 deprecation warnings (non-blocking, can address in future maintenance)
- FastAPI Query.regex deprecation (existing code, not introduced by this story)

### Recommendations

**For This Story:**
- âœ… **APPROVED for production deployment** - No blocking issues

**For Future Enhancement:**
- Consider implementing pagination for transcripts if sessions regularly exceed 1000 messages
- Address Pydantic V2 migration during next major dependency upgrade
- Update existing session endpoints to use `pattern` instead of `regex` for query params

### Next Steps

**Recommended Status Change:** Ready for Review â†’ **Done**

**Production Readiness:** âœ… YES - All quality gates passed

This story sets a high quality bar for the team. Excellent work by James (Dev Agent).

---

**QA Review Complete** | Gate: PASS | Score: 92/100
