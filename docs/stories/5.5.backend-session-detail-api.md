# Story 5.5: Backend Session Detail API

**Epic:** Epic 5 - Session Management & History  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** backend developer,  
**I want** an API endpoint that returns complete session details including full transcript,  
**so that** students can view their past conversations.

---

## Acceptance Criteria

1. GET /api/sessions/:sessionId endpoint created requiring authentication.
2. Endpoint queries sessions table for record matching session_id and authenticated user_id.
3. Response includes: session_id, counselor_category, mode, started_at, ended_at, duration_seconds, full transcript (JSON array of messages).
4. Endpoint returns 404 if session_id not found, 403 if session belongs to different user.
5. Transcript deserialized from database TEXT field into JSON array structure: [{ timestamp: ISO string, speaker: "user"|"counselor", text: string }].
6. Unit tests verify authorization logic and data structure.

---

## Tasks / Subtasks

- [x] Create session detail endpoint (AC: 1)
  - [x] Add GET /api/sessions/{session_id} route
  - [x] Apply authentication dependency
  - [x] Parse sessionId from path parameter
  
- [x] Implement query with authorization (AC: 2)
  - [x] Query sessions table by session_id
  - [x] Filter by authenticated user_id
  - [x] Join with counselor_categories table
  - [x] Exclude soft-deleted sessions
  
- [x] Format response data (AC: 3, 5)
  - [x] Include all required fields
  - [x] Return full transcript array
  - [x] Format timestamps as ISO strings
  - [x] Include counselor category name and icon
  - [x] Include quality metrics if available
  
- [x] Add error handling (AC: 4)
  - [x] Return 404 if session not found
  - [x] Return 403 if user doesn't own session
  - [x] Handle database errors gracefully
  - [x] Log errors for debugging
  
- [x] Write comprehensive tests (AC: 6)
  - [x] Test authentication requirement
  - [x] Test authorization (403 for wrong user)
  - [x] Test 404 for non-existent session
  - [x] Test successful response structure
  - [x] Test transcript deserialization
  - [x] Test soft-deleted session exclusion

---

## Dev Notes

### Architecture Overview

**Endpoint Flow:**
1. Request received with JWT token and sessionId
2. Authenticate user from token
3. Query database for session by ID
4. Verify user owns session
5. Format response with full transcript
6. Return JSON response

### Backend Session Detail Endpoint

**app/routers/sessions.py (add to existing file):**
```python
from fastapi import APIRouter, Depends, HTTPException, Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from app.database import get_db
from app.models import User, Session, CounselorCategory
from app.auth import get_current_user
from pydantic import BaseModel
from typing import List, Optional, Any
from datetime import datetime
import uuid

router = APIRouter(prefix="/sessions", tags=["sessions"])

class TranscriptMessage(BaseModel):
    timestamp: str
    speaker: str  # 'user' or 'counselor'
    text: str

class SessionDetailResponse(BaseModel):
    session_id: str
    counselor_category: str
    counselor_icon: str
    mode: str
    started_at: str
    ended_at: str
    duration_seconds: int
    transcript: List[TranscriptMessage]
    quality_metrics: Optional[dict] = None

@router.get("/{session_id}", response_model=SessionDetailResponse)
async def get_session_detail(
    session_id: str = Path(..., description="UUID of the session"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get complete session details including full transcript.
    
    Only the session owner can access this endpoint.
    """
    try:
        # Validate UUID format
        try:
            session_uuid = uuid.UUID(session_id)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid session ID format")
        
        # Query session with counselor category
        query = (
            select(Session, CounselorCategory)
            .join(CounselorCategory, Session.counselor_category == CounselorCategory.category_id)
            .where(
                and_(
                    Session.session_id == session_uuid,
                    Session.deleted_at.is_(None)
                )
            )
        )
        
        result = await db.execute(query)
        row = result.first()
        
        # Check if session exists
        if not row:
            raise HTTPException(status_code=404, detail="Session not found")
        
        session, category = row
        
        # Check authorization - user must own the session
        if session.user_id != current_user.user_id:
            raise HTTPException(
                status_code=403,
                detail="You do not have permission to access this session"
            )
        
        # Format transcript
        transcript_messages = []
        if session.transcript:
            for msg in session.transcript:
                transcript_messages.append(TranscriptMessage(
                    timestamp=msg.get('timestamp', ''),
                    speaker=msg.get('speaker', 'unknown'),
                    text=msg.get('text', '')
                ))
        
        # Build response
        return SessionDetailResponse(
            session_id=str(session.session_id),
            counselor_category=category.name,
            counselor_icon=category.icon,
            mode=session.mode,
            started_at=session.start_time.isoformat(),
            ended_at=session.end_time.isoformat() if session.end_time else session.start_time.isoformat(),
            duration_seconds=session.duration_seconds,
            transcript=transcript_messages,
            quality_metrics=session.quality_metrics
        )
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to fetch session details: {str(e)}")
```

### Source Tree Updates

```
packages/backend/
└── app/
    └── routers/
        └── sessions.py           # Add GET /{session_id} endpoint
```

---

## Testing

### Testing Requirements:

1. **Authentication Test:**
   ```python
   def test_get_session_detail_requires_auth():
       """Test that endpoint requires authentication"""
       response = client.get("/api/v1/sessions/123e4567-e89b-12d3-a456-426614174000")
       assert response.status_code == 401
   ```

2. **Authorization Test:**
   ```python
   @pytest.mark.asyncio
   async def test_get_session_detail_authorization(db_session, test_users, test_category):
       """Test that users can only access their own sessions"""
       user1, user2 = test_users
       
       # Create session for user1
       session = Session(
           user_id=user1.user_id,
           counselor_category=test_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           end_time=datetime.utcnow(),
           duration_seconds=300,
           transcript=[
               {'timestamp': '2025-12-20T10:00:00Z', 'speaker': 'user', 'text': 'Hello'}
           ]
       )
       db_session.add(session)
       await db_session.commit()
       await db_session.refresh(session)
       
       # User2 tries to access user1's session - should get 403
       token = create_test_token(user2)
       response = client.get(
           f"/api/v1/sessions/{session.session_id}",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 403
       assert 'permission' in response.json()['detail'].lower()
   ```

3. **Success Test:**
   ```python
   @pytest.mark.asyncio
   async def test_get_session_detail_success(db_session, test_user, test_category):
       """Test successful session detail retrieval"""
       # Create session
       transcript_data = [
           {'timestamp': '2025-12-20T10:00:00Z', 'speaker': 'user', 'text': 'I need help'},
           {'timestamp': '2025-12-20T10:00:05Z', 'speaker': 'counselor', 'text': 'How can I assist you?'}
       ]
       
       session = Session(
           user_id=test_user.user_id,
           counselor_category=test_category.category_id,
           mode='voice',
           start_time=datetime.utcnow(),
           end_time=datetime.utcnow(),
           duration_seconds=300,
           transcript=transcript_data,
           quality_metrics={'connection_quality_average': 'good'}
       )
       db_session.add(session)
       await db_session.commit()
       await db_session.refresh(session)
       
       # Fetch session
       token = create_test_token(test_user)
       response = client.get(
           f"/api/v1/sessions/{session.session_id}",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert data['session_id'] == str(session.session_id)
       assert data['counselor_category'] == test_category.name
       assert data['mode'] == 'voice'
       assert data['duration_seconds'] == 300
       assert len(data['transcript']) == 2
       assert data['transcript'][0]['text'] == 'I need help'
       assert data['quality_metrics']['connection_quality_average'] == 'good'
   ```

4. **Not Found Test:**
   ```python
   def test_get_session_detail_not_found(test_user):
       """Test 404 for non-existent session"""
       token = create_test_token(test_user)
       fake_uuid = str(uuid.uuid4())
       
       response = client.get(
           f"/api/v1/sessions/{fake_uuid}",
           headers={"Authorization": f"Bearer {token}"}
       )
       
       assert response.status_code == 404
   ```

5. **Manual Testing Checklist:**
   - [x] Endpoint requires authentication
   - [x] Returns 401 without JWT token
   - [x] Users can only access their own sessions
   - [x] Returns 403 for unauthorized access
   - [x] Returns 404 for non-existent session
   - [x] Returns complete session data
   - [x] Full transcript included in response
   - [x] Transcript messages properly formatted
   - [x] Timestamps in ISO format
   - [x] Quality metrics included if available
   - [x] Counselor category name and icon included
   - [x] Soft-deleted sessions return 404
   - [x] Invalid UUID format returns 422
   - [x] Database errors handled gracefully

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-12-22 | 2.0 | Implementation complete | James (Dev) |

---

## Dev Agent Record

### Status
Ready for Review

### Agent Model Used
Claude Sonnet 4.5

### Completion Notes

Successfully implemented GET /api/v1/sessions/{session_id} endpoint with full requirements:

**Key Accomplishments:**
- Enhanced existing endpoint to include counselor category JOIN for icon/name
- Added quality_metrics field to Session model and schema
- Created database migration for quality_metrics column (JSONB)
- Implemented comprehensive authorization (user ownership validation)
- Proper soft-delete handling (excludes deleted_at sessions)
- Full transcript deserialization from JSONB
- ISO timestamp formatting for all datetime fields
- Comprehensive test coverage: 8 new tests (all passing)
- Updated 2 existing tests to accommodate counselor category requirement

**Technical Implementation:**
- Updated SessionDetail schema to include counselor_icon and quality_metrics
- Modified endpoint to perform INNER JOIN between sessions and counselor_categories tables
- Enhanced error handling for 404 (not found), 403 (unauthorized), 422 (invalid UUID)
- Maintained consistency with existing session endpoints

**Testing:**
- 8 comprehensive tests in test_session_detail.py (100% pass rate)
- Tests cover: authentication, authorization, not found, soft-delete, success cases, quality metrics, empty transcript, invalid UUID
- Updated 2 existing tests in test_routers/test_sessions.py to create counselor categories
- All backend tests passing (149 tests, excluding unrelated pipecat failures)

### Debug Log References
No debugging required - implementation completed on first pass with minor import fix

### File List

**Modified:**
- [packages/backend/app/routers/sessions.py](../../../packages/backend/app/routers/sessions.py) - Enhanced GET /{session_id} endpoint with counselor category JOIN
- [packages/backend/app/models/session.py](../../../packages/backend/app/models/session.py) - Added quality_metrics field
- [packages/backend/app/schemas/session.py](../../../packages/backend/app/schemas/session.py) - Added counselor_icon and quality_metrics to SessionDetail
- [packages/backend/tests/test_routers/test_sessions.py](../../../packages/backend/tests/test_routers/test_sessions.py) - Updated existing tests to create counselor categories

**Created:**
- [packages/backend/alembic/versions/672c05922909_add_quality_metrics_to_sessions.py](../../../packages/backend/alembic/versions/672c05922909_add_quality_metrics_to_sessions.py) - Migration for quality_metrics column
- [packages/backend/tests/test_session_detail.py](../../../packages/backend/tests/test_session_detail.py) - Comprehensive test suite for session detail endpoint

### Change Log

- Enhanced SessionDetail response schema with counselor_icon and quality_metrics fields
- Implemented database JOIN with counselor_categories table for complete session data
- Added quality_metrics JSONB column to sessions table via migration
- Created comprehensive test suite covering all acceptance criteria
- Updated existing tests to support counselor category requirement
