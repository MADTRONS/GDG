# Story 6.1: Admin User Model and Authentication

**Epic:** Epic 6 - Admin Dashboard & Counselor Management  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** system administrator,  
**I want** a secure admin login system separate from student authentication,  
**so that** I can access administrative functions with appropriate permissions.

---

## Acceptance Criteria

1. Admin table created in database with fields: id (UUID), email (unique), password_hash, role (enum: SUPER_ADMIN, SYSTEM_MONITOR, CONTENT_MANAGER), is_active (boolean), created_at, updated_at.
2. POST /api/admin/auth/login endpoint accepts email and password, returns JWT with admin claims.
3. Admin JWT tokens include role and permissions in claims, expire in 8 hours.
4. Admin authentication middleware verifies JWT and checks role permissions for protected routes.
5. Admins cannot access student authentication endpoints and vice versa.
6. Admin login page at /admin/login with email/password form (separate from student login).
7. Initial seed script creates default super admin account with environment-configured credentials.
8. Unit tests cover admin authentication, authorization, and role-based access control.

---

## Tasks / Subtasks

- [ ] Create Admin table and model (AC: 1)
  - [ ] Define Admin model with SQLAlchemy
  - [ ] Add role enum (SUPER_ADMIN, SYSTEM_MONITOR, CONTENT_MANAGER)
  - [ ] Create Alembic migration script
  - [ ] Add indexes on email and is_active
  
- [ ] Implement admin login endpoint (AC: 2)
  - [ ] Create POST /api/admin/auth/login route
  - [ ] Validate email and password
  - [ ] Query Admin table for user
  - [ ] Verify password with bcrypt
  - [ ] Generate JWT with admin claims
  - [ ] Set JWT in httpOnly cookie
  
- [ ] Configure JWT token with admin claims (AC: 3)
  - [ ] Include role in token payload
  - [ ] Include permissions list based on role
  - [ ] Set expiration to 8 hours
  - [ ] Use separate secret key for admin tokens (optional)
  
- [ ] Create admin authentication middleware (AC: 4)
  - [ ] Verify JWT token from cookie
  - [ ] Extract admin user from token
  - [ ] Check role permissions
  - [ ] Return 403 if insufficient permissions
  
- [ ] Separate admin and student auth (AC: 5)
  - [ ] Admin routes under /api/admin/* namespace
  - [ ] Student routes under /api/v1/* namespace
  - [ ] Middleware validates correct user type
  
- [ ] Create admin login page (AC: 6)
  - [ ] Build /admin/login route
  - [ ] Email/password form with validation
  - [ ] Call login endpoint
  - [ ] Redirect to /admin/dashboard on success
  - [ ] Display error messages
  
- [ ] Add seed script for initial admin (AC: 7)
  - [ ] Read admin credentials from env vars
  - [ ] Create super admin on first run
  - [ ] Skip if admin already exists
  
- [ ] Write comprehensive tests (AC: 8)
  - [ ] Test admin login flow
  - [ ] Test JWT token generation
  - [ ] Test authentication middleware
  - [ ] Test role-based authorization
  - [ ] Test separation from student auth

---

## Dev Notes

### Architecture Overview

**Admin Auth Flow:**
```
Admin submits login form
↓
POST /api/admin/auth/login
↓
Validate email/password
↓
Query Admin table
↓
Verify bcrypt password
↓
Generate JWT with role claims
↓
Set httpOnly cookie
↓
Return success response
↓
Redirect to /admin/dashboard
```

### Database Model

**app/models.py (add new model):**
```python
from sqlalchemy import Column, String, Boolean, DateTime, Enum
from sqlalchemy.dialects.postgresql import UUID
from datetime import datetime
import uuid
import enum

class AdminRole(str, enum.Enum):
    SUPER_ADMIN = "SUPER_ADMIN"
    SYSTEM_MONITOR = "SYSTEM_MONITOR"
    CONTENT_MANAGER = "CONTENT_MANAGER"

class Admin(Base):
    __tablename__ = "admin_users"
    
    admin_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    role = Column(Enum(AdminRole), nullable=False, default=AdminRole.CONTENT_MANAGER)
    is_active = Column(Boolean, default=True, nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    last_login_at = Column(DateTime, nullable=True)
    
    def __repr__(self):
        return f"<Admin {self.email} ({self.role.value})>"
```

### Alembic Migration

**alembic/versions/007_create_admin_users.py:**
```python
"""Create admin_users table

Revision ID: 007
Revises: 006
Create Date: 2025-12-20 10:00:00.000000
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

def upgrade():
    op.create_table(
        'admin_users',
        sa.Column('admin_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('email', sa.String(255), nullable=False),
        sa.Column('password_hash', sa.String(255), nullable=False),
        sa.Column('role', sa.Enum('SUPER_ADMIN', 'SYSTEM_MONITOR', 'CONTENT_MANAGER', name='adminrole'), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('now()')),
        sa.Column('last_login_at', sa.DateTime(), nullable=True),
        sa.PrimaryKeyConstraint('admin_id')
    )
    op.create_index('ix_admin_users_email', 'admin_users', ['email'], unique=True)
    op.create_index('ix_admin_users_is_active', 'admin_users', ['is_active'])

def downgrade():
    op.drop_index('ix_admin_users_is_active', table_name='admin_users')
    op.drop_index('ix_admin_users_email', table_name='admin_users')
    op.drop_table('admin_users')
    op.execute('DROP TYPE adminrole')
```

### Backend Auth Router

**app/routers/admin_auth.py (new file):**
```python
from fastapi import APIRouter, Depends, HTTPException, Response, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import get_db
from app.models import Admin, AdminRole
from pydantic import BaseModel, EmailStr
import bcrypt
import jwt
from datetime import datetime, timedelta
from typing import Optional
import os

router = APIRouter(prefix="/admin/auth", tags=["admin-auth"])

# Configuration
ADMIN_SECRET_KEY = os.getenv("ADMIN_JWT_SECRET", os.getenv("JWT_SECRET"))
ALGORITHM = "HS256"
ADMIN_TOKEN_EXPIRE_HOURS = 8

class AdminLoginRequest(BaseModel):
    email: EmailStr
    password: str

class AdminLoginResponse(BaseModel):
    email: str
    role: str
    message: str

def create_admin_token(admin: Admin) -> str:
    """
    Create JWT token for admin user with role claims.
    """
    payload = {
        "sub": str(admin.admin_id),
        "email": admin.email,
        "role": admin.role.value,
        "type": "admin",  # Distinguish from student tokens
        "exp": datetime.utcnow() + timedelta(hours=ADMIN_TOKEN_EXPIRE_HOURS)
    }
    return jwt.encode(payload, ADMIN_SECRET_KEY, algorithm=ALGORITHM)

@router.post("/login", response_model=AdminLoginResponse)
async def admin_login(
    login_data: AdminLoginRequest,
    response: Response,
    db: AsyncSession = Depends(get_db)
):
    """
    Admin login endpoint. Returns JWT token with admin role claims.
    """
    try:
        # Query admin user
        query = select(Admin).where(
            Admin.email == login_data.email.lower(),
            Admin.is_active == True
        )
        result = await db.execute(query)
        admin = result.scalar_one_or_none()
        
        # Check if admin exists
        if not admin:
            raise HTTPException(
                status_code=401,
                detail="Invalid email or password"
            )
        
        # Verify password
        password_correct = bcrypt.checkpw(
            login_data.password.encode('utf-8'),
            admin.password_hash.encode('utf-8')
        )
        
        if not password_correct:
            raise HTTPException(
                status_code=401,
                detail="Invalid email or password"
            )
        
        # Update last login
        admin.last_login_at = datetime.utcnow()
        await db.commit()
        
        # Generate JWT token
        token = create_admin_token(admin)
        
        # Set httpOnly cookie
        response.set_cookie(
            key="admin_token",
            value=token,
            httponly=True,
            secure=True,  # Set to True in production with HTTPS
            samesite="lax",
            max_age=ADMIN_TOKEN_EXPIRE_HOURS * 3600
        )
        
        return AdminLoginResponse(
            email=admin.email,
            role=admin.role.value,
            message="Login successful"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Login failed: {str(e)}")

@router.post("/logout")
async def admin_logout(response: Response):
    """
    Admin logout endpoint. Clears admin token cookie.
    """
    response.delete_cookie(key="admin_token")
    return {"message": "Logout successful"}
```

### Admin Authentication Middleware

**app/auth.py (add admin functions):**
```python
from fastapi import HTTPException, Request, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import get_db
from app.models import Admin, AdminRole
import jwt
import os

ADMIN_SECRET_KEY = os.getenv("ADMIN_JWT_SECRET", os.getenv("JWT_SECRET"))
ALGORITHM = "HS256"

async def get_current_admin(request: Request, db: AsyncSession = Depends(get_db)) -> Admin:
    """
    Dependency to get current authenticated admin user from JWT token.
    """
    # Extract token from cookie
    token = request.cookies.get("admin_token")
    
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    try:
        # Decode JWT
        payload = jwt.decode(token, ADMIN_SECRET_KEY, algorithms=[ALGORITHM])
        
        # Verify token type
        if payload.get("type") != "admin":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Invalid token type"
            )
        
        admin_id = payload.get("sub")
        if not admin_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        
        # Query admin from database
        query = select(Admin).where(
            Admin.admin_id == admin_id,
            Admin.is_active == True
        )
        result = await db.execute(query)
        admin = result.scalar_one_or_none()
        
        if not admin:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Admin not found or inactive"
            )
        
        return admin
        
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token expired"
        )
    except jwt.JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

def require_admin_role(*allowed_roles: AdminRole):
    """
    Dependency factory to require specific admin roles.
    
    Usage:
    @router.get("/admin/users", dependencies=[Depends(require_admin_role(AdminRole.SUPER_ADMIN))])
    """
    async def role_checker(admin: Admin = Depends(get_current_admin)):
        if admin.role not in allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of roles: {', '.join(r.value for r in allowed_roles)}"
            )
        return admin
    return role_checker
```

### Seed Script for Initial Admin

**scripts/seed_admin.py:**
```python
import asyncio
import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from app.models import Admin, AdminRole
import bcrypt
import uuid

DATABASE_URL = os.getenv("DATABASE_URL")
DEFAULT_ADMIN_EMAIL = os.getenv("DEFAULT_ADMIN_EMAIL", "admin@example.com")
DEFAULT_ADMIN_PASSWORD = os.getenv("DEFAULT_ADMIN_PASSWORD", "changeme123")

async def seed_default_admin():
    engine = create_async_engine(DATABASE_URL)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
    
    async with async_session() as session:
        # Check if admin already exists
        from sqlalchemy import select
        result = await session.execute(select(Admin).where(Admin.email == DEFAULT_ADMIN_EMAIL))
        existing_admin = result.scalar_one_or_none()
        
        if existing_admin:
            print(f"Admin user {DEFAULT_ADMIN_EMAIL} already exists. Skipping.")
            return
        
        # Create default admin
        password_hash = bcrypt.hashpw(DEFAULT_ADMIN_PASSWORD.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        
        admin = Admin(
            admin_id=uuid.uuid4(),
            email=DEFAULT_ADMIN_EMAIL,
            password_hash=password_hash,
            role=AdminRole.SUPER_ADMIN,
            is_active=True
        )
        
        session.add(admin)
        await session.commit()
        
        print(f"Created default super admin: {DEFAULT_ADMIN_EMAIL}")
        print(f"Password: {DEFAULT_ADMIN_PASSWORD}")
        print("IMPORTANT: Change this password immediately!")

if __name__ == "__main__":
    asyncio.run(seed_default_admin())
```

### Frontend Admin Login Page

**app/admin/login/page.tsx:**
```typescript
'use client';

import { useState, FormEvent } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/components/ui/use-toast';
import { ShieldCheck } from 'lucide-react';

export default function AdminLoginPage() {
  const router = useRouter();
  const { toast } = useToast();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const response = await fetch('/api/admin/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'Login failed');
      }

      const data = await response.json();

      toast({
        title: "Login Successful",
        description: `Welcome back, ${data.role}`
      });

      // Redirect to admin dashboard
      router.push('/admin/dashboard');

    } catch (error) {
      console.error('Login error:', error);
      toast({
        title: "Login Failed",
        description: error instanceof Error ? error.message : "Invalid credentials",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <ShieldCheck className="h-12 w-12 text-blue-600" />
          </div>
          <CardTitle className="text-2xl">Admin Login</CardTitle>
          <CardDescription>Access the administrative dashboard</CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <Label htmlFor="email">Email Address</Label>
              <Input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                placeholder="admin@example.com"
                disabled={loading}
              />
            </div>
            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                placeholder="••••••••"
                disabled={loading}
              />
            </div>
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? 'Logging in...' : 'Login'}
            </Button>
          </form>
          <div className="mt-6 text-center text-sm text-gray-600">
            <p>This is an administrative area. Unauthorized access is prohibited.</p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### Source Tree Updates

```
packages/backend/
├── alembic/
│   └── versions/
│       └── 007_create_admin_users.py  # New migration
├── app/
│   ├── models.py                   # Add Admin model
│   ├── auth.py                     # Add admin auth functions
│   └── routers/
│       └── admin_auth.py           # New admin auth router
└── scripts/
    └── seed_admin.py               # Seed script

packages/frontend/
└── app/
    └── admin/
        └── login/
            └── page.tsx                # Admin login page
```

---

## Testing

### Testing Requirements:

1. **Admin Login Test:**
   ```python
   @pytest.mark.asyncio
   async def test_admin_login_success(db_session):
       """Test successful admin login"""
       # Create admin user
       password = "testpassword123"
       password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
       
       admin = Admin(
           email="test@admin.com",
           password_hash=password_hash,
           role=AdminRole.SUPER_ADMIN,
           is_active=True
       )
       db_session.add(admin)
       await db_session.commit()
       
       # Attempt login
       response = client.post(
           "/api/admin/auth/login",
           json={"email": "test@admin.com", "password": password}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert data["email"] == "test@admin.com"
       assert data["role"] == "SUPER_ADMIN"
       assert "admin_token" in response.cookies
   ```

2. **Authentication Middleware Test:**
   ```python
   def test_admin_endpoint_requires_auth():
       """Test that admin endpoints require authentication"""
       response = client.get("/api/admin/counselors/categories")
       assert response.status_code == 401
   ```

3. **Role-Based Authorization Test:**
   ```python
   def test_super_admin_only_endpoint(test_content_manager):
       """Test that content manager cannot access super admin endpoints"""
       token = create_admin_token(test_content_manager)
       
       response = client.get(
           "/api/admin/users",
           cookies={"admin_token": token}
       )
       
       assert response.status_code == 403
   ```

4. **Token Expiration Test:**
   ```python
   def test_expired_token_rejected(test_admin):
       """Test that expired tokens are rejected"""
       # Create expired token
       payload = {
           "sub": str(test_admin.admin_id),
           "type": "admin",
           "exp": datetime.utcnow() - timedelta(hours=1)  # Expired
       }
       expired_token = jwt.encode(payload, ADMIN_SECRET_KEY, algorithm="HS256")
       
       response = client.get(
           "/api/admin/dashboard",
           cookies={"admin_token": expired_token}
       )
       
       assert response.status_code == 401
   ```

5. **Manual Testing Checklist:**
   - [ ] Admin login page accessible at /admin/login
   - [ ] Login form validates email format
   - [ ] Correct credentials allow login
   - [ ] Incorrect credentials show error
   - [ ] JWT token set in httpOnly cookie
   - [ ] Redirect to /admin/dashboard after login
   - [ ] Admin can access admin routes
   - [ ] Student cannot access admin routes
   - [ ] Admin cannot access student-only routes
   - [ ] Token expires after 8 hours
   - [ ] Logout clears token cookie
   - [ ] Seed script creates default admin
   - [ ] Seed script skips if admin exists
   - [ ] Role-based access control enforced
   - [ ] Super admin has full access
   - [ ] Content manager limited to category edits
   - [ ] System monitor read-only access

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
