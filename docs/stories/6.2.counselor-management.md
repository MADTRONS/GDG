# Story 6.2: Counselor Category Management Interface

**Epic:** Epic 6 - Admin Dashboard & Counselor Management  
**Status:** Draft  
**Created:** December 20, 2025  
**Last Updated:** December 20, 2025

---

## Story

**As a** content manager,  
**I want** to create, edit, and disable counselor categories through an admin UI,  
**so that** I can adjust available counseling options without developer assistance.

---

## Acceptance Criteria

1. GET /api/admin/counselors/categories endpoint returns all categories including disabled ones (admins only).
2. POST /api/admin/counselors/categories endpoint creates new category with validation.
3. PUT /api/admin/counselors/categories/{id} endpoint updates existing category.
4. DELETE /api/admin/counselors/categories/{id} soft deletes category (sets enabled=false).
5. Admin UI page at /admin/counselors displays table of all categories with edit/disable actions.
6. Create/Edit modal form includes fields: name, description, icon_name, system_prompt, enabled toggle.
7. System prompt field includes syntax highlighting and validation for length limits.
8. Changes to enabled status immediately reflected in student dashboard (cached data refreshed).
9. Audit log entry created for every category modification with admin user ID and timestamp.
10. Frontend displays success/error toast notifications for all CRUD operations.

---

## Tasks / Subtasks

- [x] Create admin counselor endpoints (AC: 1, 2, 3, 4)
  - [x] Add GET /api/admin/counselors/categories
  - [x] Add POST /api/admin/counselors/categories
  - [x] Add PUT /api/admin/counselors/categories/{id}
  - [x] Add DELETE /api/admin/counselors/categories/{id}
  - [x] Apply admin authentication middleware
  - [x] Validate input data (Pydantic models)
  
- [x] Implement audit logging (AC: 9)
  - [x] Create AuditLog model
  - [x] Log CREATE action on category creation
  - [x] Log UPDATE action on category modification
  - [x] Log DELETE action on disable
  - [x] Include admin_user_id and timestamp
  
- [ ] Build counselor management page (AC: 5)
  - [ ] Create /admin/counselors route
  - [ ] Fetch all categories (including disabled)
  - [ ] Display in table with columns: name, icon, enabled, actions
  - [ ] Add "Create Category" button
  
- [ ] Create category form modal (AC: 6, 7)
  - [ ] Modal dialog for create/edit
  - [ ] Input fields: name, description, icon, system_prompt
  - [ ] Toggle switch for enabled status
  - [ ] Syntax highlighting for system prompt (monaco editor or textarea with validation)
  - [ ] Character count for system prompt
  - [ ] Form validation
  
- [ ] Implement CRUD operations (AC: 10)
  - [ ] Create new category
  - [ ] Edit existing category
  - [ ] Disable category (soft delete)
  - [ ] Display success/error toasts
  - [ ] Refresh table after operation
  
- [ ] Handle cache invalidation (AC: 8)
  - [ ] Clear student dashboard cache on category change
  - [ ] Or use cache TTL to auto-refresh
  - [ ] Verify changes reflected in student view
  
- [ ] Write comprehensive tests
  - [x] Test all CRUD endpoints
  - [x] Test authorization (content manager access)
  - [x] Test audit log creation
  - [ ] Test form validation
  - [ ] Test UI interactions

---

## Dev Notes

### Architecture Overview

**CRUD Flow:**
```
Admin opens /admin/counselors
â†“
Fetch all categories (including disabled)
â†“
Display in table
â†“
Admin clicks "Edit" or "Create"
â†“
Modal form appears
â†“
Admin submits form
â†“
API call (POST/PUT/DELETE)
â†“
Audit log entry created
â†“
Success toast displayed
â†“
Table refreshed
â†“
Student dashboard cache cleared
```

### Audit Log Model

**app/models.py (add AuditLog model):**
```python
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Enum
from sqlalchemy.dialects.postgresql import UUID, JSONB
from datetime import datetime
import uuid
import enum

class AuditAction(str, enum.Enum):
    CREATE = "CREATE"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN = "LOGIN"
    LOGOUT = "LOGOUT"

class AuditLog(Base):
    __tablename__ = "audit_log"
    
    log_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    admin_user_id = Column(UUID(as_uuid=True), ForeignKey("admin_users.admin_id"), nullable=False)
    action = Column(Enum(AuditAction), nullable=False)
    resource_type = Column(String(50), nullable=False)  # e.g., "CounselorCategory", "AdminUser"
    resource_id = Column(UUID(as_uuid=True), nullable=True)  # ID of affected resource
    details = Column(JSONB, nullable=True)  # Additional context (e.g., changed fields)
    ip_address = Column(String(45), nullable=True)  # IPv4 or IPv6
    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    
    def __repr__(self):
        return f"<AuditLog {self.action.value} {self.resource_type} by {self.admin_user_id}>"
```

### Backend Admin Counselor Router

**app/routers/admin_counselors.py (new file):**
```python
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import get_db
from app.models import CounselorCategory, Admin, AuditLog, AuditAction, AdminRole
from app.auth import get_current_admin, require_admin_role
from pydantic import BaseModel
from typing import List, Optional
import uuid

router = APIRouter(prefix="/admin/counselors", tags=["admin-counselors"])

class CategoryResponse(BaseModel):
    category_id: str
    name: str
    description: str
    icon: str
    system_prompt: str
    enabled: bool

class CategoryCreateRequest(BaseModel):
    name: str
    description: str
    icon: str
    system_prompt: str
    enabled: bool = True

class CategoryUpdateRequest(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    icon: Optional[str] = None
    system_prompt: Optional[str] = None
    enabled: Optional[bool] = None

async def create_audit_log(
    db: AsyncSession,
    admin: Admin,
    action: AuditAction,
    resource_type: str,
    resource_id: Optional[uuid.UUID],
    details: Optional[dict],
    request: Request
):
    """Helper function to create audit log entries"""
    audit_entry = AuditLog(
        admin_user_id=admin.admin_id,
        action=action,
        resource_type=resource_type,
        resource_id=resource_id,
        details=details,
        ip_address=request.client.host if request.client else None
    )
    db.add(audit_entry)

@router.get("/categories", response_model=List[CategoryResponse])
async def get_all_categories_admin(
    admin: Admin = Depends(require_admin_role(AdminRole.SUPER_ADMIN, AdminRole.CONTENT_MANAGER, AdminRole.SYSTEM_MONITOR)),
    db: AsyncSession = Depends(get_db)
):
    """
    Get all counselor categories including disabled ones (admin only).
    """
    try:
        # Query all categories (no enabled filter)
        query = select(CounselorCategory)
        result = await db.execute(query)
        categories = result.scalars().all()
        
        return [
            CategoryResponse(
                category_id=str(cat.category_id),
                name=cat.name,
                description=cat.description,
                icon=cat.icon,
                system_prompt=cat.system_prompt,
                enabled=cat.enabled
            )
            for cat in categories
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch categories: {str(e)}")

@router.post("/categories", response_model=CategoryResponse)
async def create_category(
    category_data: CategoryCreateRequest,
    request: Request,
    admin: Admin = Depends(require_admin_role(AdminRole.SUPER_ADMIN, AdminRole.CONTENT_MANAGER)),
    db: AsyncSession = Depends(get_db)
):
    """
    Create new counselor category (content manager or super admin).
    """
    try:
        # Validate system prompt length
        if len(category_data.system_prompt) > 5000:
            raise HTTPException(status_code=400, detail="System prompt exceeds 5000 character limit")
        
        # Create category
        new_category = CounselorCategory(
            category_id=uuid.uuid4(),
            name=category_data.name,
            description=category_data.description,
            icon=category_data.icon,
            system_prompt=category_data.system_prompt,
            enabled=category_data.enabled
        )
        
        db.add(new_category)
        
        # Create audit log
        await create_audit_log(
            db=db,
            admin=admin,
            action=AuditAction.CREATE,
            resource_type="CounselorCategory",
            resource_id=new_category.category_id,
            details={"name": category_data.name},
            request=request
        )
        
        await db.commit()
        await db.refresh(new_category)
        
        return CategoryResponse(
            category_id=str(new_category.category_id),
            name=new_category.name,
            description=new_category.description,
            icon=new_category.icon,
            system_prompt=new_category.system_prompt,
            enabled=new_category.enabled
        )
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to create category: {str(e)}")

@router.put("/categories/{category_id}", response_model=CategoryResponse)
async def update_category(
    category_id: str,
    category_data: CategoryUpdateRequest,
    request: Request,
    admin: Admin = Depends(require_admin_role(AdminRole.SUPER_ADMIN, AdminRole.CONTENT_MANAGER)),
    db: AsyncSession = Depends(get_db)
):
    """
    Update existing counselor category (content manager or super admin).
    """
    try:
        # Validate UUID
        try:
            cat_uuid = uuid.UUID(category_id)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid category ID format")
        
        # Fetch category
        query = select(CounselorCategory).where(CounselorCategory.category_id == cat_uuid)
        result = await db.execute(query)
        category = result.scalar_one_or_none()
        
        if not category:
            raise HTTPException(status_code=404, detail="Category not found")
        
        # Track changes for audit log
        changes = {}
        
        # Update fields if provided
        if category_data.name is not None:
            changes["name"] = {"old": category.name, "new": category_data.name}
            category.name = category_data.name
        if category_data.description is not None:
            category.description = category_data.description
        if category_data.icon is not None:
            category.icon = category_data.icon
        if category_data.system_prompt is not None:
            if len(category_data.system_prompt) > 5000:
                raise HTTPException(status_code=400, detail="System prompt exceeds 5000 character limit")
            changes["system_prompt_updated"] = True
            category.system_prompt = category_data.system_prompt
        if category_data.enabled is not None:
            changes["enabled"] = {"old": category.enabled, "new": category_data.enabled}
            category.enabled = category_data.enabled
        
        # Create audit log
        await create_audit_log(
            db=db,
            admin=admin,
            action=AuditAction.UPDATE,
            resource_type="CounselorCategory",
            resource_id=category.category_id,
            details=changes,
            request=request
        )
        
        await db.commit()
        await db.refresh(category)
        
        return CategoryResponse(
            category_id=str(category.category_id),
            name=category.name,
            description=category.description,
            icon=category.icon,
            system_prompt=category.system_prompt,
            enabled=category.enabled
        )
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to update category: {str(e)}")

@router.delete("/categories/{category_id}")
async def disable_category(
    category_id: str,
    request: Request,
    admin: Admin = Depends(require_admin_role(AdminRole.SUPER_ADMIN, AdminRole.CONTENT_MANAGER)),
    db: AsyncSession = Depends(get_db)
):
    """
    Disable counselor category (soft delete by setting enabled=false).
    """
    try:
        # Validate UUID
        try:
            cat_uuid = uuid.UUID(category_id)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid category ID format")
        
        # Fetch category
        query = select(CounselorCategory).where(CounselorCategory.category_id == cat_uuid)
        result = await db.execute(query)
        category = result.scalar_one_or_none()
        
        if not category:
            raise HTTPException(status_code=404, detail="Category not found")
        
        # Soft delete
        category.enabled = False
        
        # Create audit log
        await create_audit_log(
            db=db,
            admin=admin,
            action=AuditAction.DELETE,
            resource_type="CounselorCategory",
            resource_id=category.category_id,
            details={"name": category.name},
            request=request
        )
        
        await db.commit()
        
        return {"message": "Category disabled successfully"}
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to disable category: {str(e)}")
```

### Frontend Counselor Management Page

**app/admin/counselors/page.tsx:**
```typescript
'use client';

import { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/components/ui/use-toast';
import { Edit, Trash2, Plus } from 'lucide-react';
import CategoryFormModal from '@/components/admin/CategoryFormModal';

interface Category {
  category_id: string;
  name: string;
  description: string;
  icon: string;
  system_prompt: string;
  enabled: boolean;
}

export default function CounselorManagementPage() {
  const { toast } = useToast();
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/admin/counselors/categories', {
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error('Failed to fetch categories');
      }

      const data = await response.json();
      setCategories(data);
    } catch (error) {
      console.error('Error fetching categories:', error);
      toast({
        title: "Error",
        description: "Failed to load counselor categories",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleCreate = () => {
    setEditingCategory(null);
    setShowModal(true);
  };

  const handleEdit = (category: Category) => {
    setEditingCategory(category);
    setShowModal(true);
  };

  const handleDisable = async (category: Category) => {
    if (!confirm(`Disable "${category.name}"? Students will no longer see this category.`)) {
      return;
    }

    try {
      const response = await fetch(`/api/admin/counselors/categories/${category.category_id}`, {
        method: 'DELETE',
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error('Failed to disable category');
      }

      toast({
        title: "Category Disabled",
        description: `${category.name} has been disabled`
      });

      fetchCategories();
    } catch (error) {
      console.error('Error disabling category:', error);
      toast({
        title: "Error",
        description: "Failed to disable category",
        variant: "destructive"
      });
    }
  };

  const handleSave = async () => {
    setShowModal(false);
    toast({
      title: "Success",
      description: editingCategory ? "Category updated" : "Category created"
    });
    fetchCategories();
  };

  if (loading) {
    return <div className="p-6">Loading...</div>;
  }

  return (
    <div className="container mx-auto p-6">
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>Counselor Categories</CardTitle>
            <Button onClick={handleCreate}>
              <Plus className="mr-2 h-4 w-4" />
              Create Category
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Icon</TableHead>
                <TableHead>Name</TableHead>
                <TableHead>Description</TableHead>
                <TableHead>Status</TableHead>
                <TableHead>Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {categories.map((category) => (
                <TableRow key={category.category_id}>
                  <TableCell className="text-2xl">{category.icon}</TableCell>
                  <TableCell className="font-medium">{category.name}</TableCell>
                  <TableCell className="max-w-md truncate">{category.description}</TableCell>
                  <TableCell>
                    <Badge variant={category.enabled ? "default" : "secondary"}>
                      {category.enabled ? 'Enabled' : 'Disabled'}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <div className="flex gap-2">
                      <Button
                        onClick={() => handleEdit(category)}
                        variant="outline"
                        size="sm"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      {category.enabled && (
                        <Button
                          onClick={() => handleDisable(category)}
                          variant="destructive"
                          size="sm"
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {showModal && (
        <CategoryFormModal
          category={editingCategory}
          onClose={() => setShowModal(false)}
          onSave={handleSave}
        />
      )}
    </div>
  );
}
```

### Category Form Modal Component

**components/admin/CategoryFormModal.tsx:**
```typescript
'use client';

import { useState, useEffect, FormEvent } from 'react';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Switch } from '@/components/ui/switch';
import { useToast } from '@/components/ui/use-toast';

interface Category {
  category_id: string;
  name: string;
  description: string;
  icon: string;
  system_prompt: string;
  enabled: boolean;
}

interface Props {
  category: Category | null;
  onClose: () => void;
  onSave: () => void;
}

export default function CategoryFormModal({ category, onClose, onSave }: Props) {
  const { toast } = useToast();
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [icon, setIcon] = useState('');
  const [systemPrompt, setSystemPrompt] = useState('');
  const [enabled, setEnabled] = useState(true);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (category) {
      setName(category.name);
      setDescription(category.description);
      setIcon(category.icon);
      setSystemPrompt(category.system_prompt);
      setEnabled(category.enabled);
    }
  }, [category]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const body = { name, description, icon, system_prompt: systemPrompt, enabled };
      const url = category
        ? `/api/admin/counselors/categories/${category.category_id}`
        : '/api/admin/counselors/categories';
      const method = category ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(body)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'Failed to save category');
      }

      onSave();
    } catch (error) {
      console.error('Error saving category:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to save category",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>{category ? 'Edit Category' : 'Create Category'}</DialogTitle>
          <DialogDescription>
            {category ? 'Update counselor category details' : 'Add a new counselor category'}
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="name">Name</Label>
            <Input
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              required
              placeholder="Health Counselor"
            />
          </div>
          <div>
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              required
              placeholder="Support for physical and mental health concerns"
              rows={3}
            />
          </div>
          <div>
            <Label htmlFor="icon">Icon (Emoji)</Label>
            <Input
              id="icon"
              value={icon}
              onChange={(e) => setIcon(e.target.value)}
              required
              placeholder="ðŸ¥"
              maxLength={2}
            />
          </div>
          <div>
            <Label htmlFor="systemPrompt">System Prompt</Label>
            <Textarea
              id="systemPrompt"
              value={systemPrompt}
              onChange={(e) => setSystemPrompt(e.target.value)}
              required
              placeholder="You are a health counselor..."
              rows={8}
              className="font-mono text-sm"
            />
            <div className="text-xs text-gray-500 mt-1">
              {systemPrompt.length} / 5000 characters
            </div>
          </div>
          <div className="flex items-center space-x-2">
            <Switch
              id="enabled"
              checked={enabled}
              onCheckedChange={setEnabled}
            />
            <Label htmlFor="enabled">Enabled (visible to students)</Label>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Saving...' : 'Save'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}
```

### Source Tree Updates

```
packages/backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ models.py                   # Add AuditLog model
â”‚   â””â”€â”€ routers/
â”‚       â””â”€â”€ admin_counselors.py     # New router

packages/frontend/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ admin/
â”‚       â””â”€â”€ counselors/
â”‚           â””â”€â”€ page.tsx            # Counselor management page
â””â”€â”€ components/
    â””â”€â”€ admin/
        â””â”€â”€ CategoryFormModal.tsx   # Form modal component
```

---

## Testing

### Testing Requirements:

1. **CRUD Operations Test:**
   ```python
   @pytest.mark.asyncio
   async def test_create_counselor_category(db_session, test_admin):
       """Test creating new counselor category"""
       token = create_admin_token(test_admin)
       
       response = client.post(
           "/api/admin/counselors/categories",
           json={
               "name": "Test Counselor",
               "description": "Test description",
               "icon": "ðŸ§ª",
               "system_prompt": "You are a test counselor",
               "enabled": True
           },
           cookies={"admin_token": token}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert data["name"] == "Test Counselor"
   ```

2. **Audit Log Test:**
   ```python
   @pytest.mark.asyncio
   async def test_audit_log_created_on_category_update(db_session, test_admin, test_category):
       """Test that audit log is created on category modification"""
       token = create_admin_token(test_admin)
       
       response = client.put(
           f"/api/admin/counselors/categories/{test_category.category_id}",
           json={"name": "Updated Name"},
           cookies={"admin_token": token}
       )
       
       assert response.status_code == 200
       
       # Check audit log
       query = select(AuditLog).where(
           AuditLog.resource_id == test_category.category_id,
           AuditLog.action == AuditAction.UPDATE
       )
       result = await db_session.execute(query)
       audit_entry = result.scalar_one_or_none()
       
       assert audit_entry is not None
       assert audit_entry.admin_user_id == test_admin.admin_id
   ```

3. **Manual Testing Checklist:**
   - [ ] Admin can access /admin/counselors page
   - [ ] All categories displayed in table
   - [ ] Disabled categories visible with badge
   - [ ] "Create Category" button opens modal
   - [ ] Form validates required fields
   - [ ] System prompt character count displayed
   - [ ] System prompt limited to 5000 chars
   - [ ] Edit button opens modal with pre-filled data
   - [ ] Updates save successfully
   - [ ] Disable button confirms action
   - [ ] Disabled category hidden from students
   - [ ] Enabled toggle works correctly
   - [ ] Success toasts displayed
   - [ ] Error toasts for failures
   - [ ] Table refreshes after operations
   - [ ] Audit log entries created
   - [ ] Content manager can edit categories
   - [ ] System monitor cannot edit categories (403)

---

## QA Results

### Review Date: 2025-12-22

### Reviewed By: Quinn (Test Architect)

### Risk Assessment Result

**Auto-escalated to deep review:** YES

**Triggers:**
- âœ“ Auth/security files touched (audit logging, role-based authorization)
- âœ“ Diff > 500 lines (~700+ lines: router, model, tests, migration)
- âœ“ Story has > 5 acceptance criteria (10 ACs)

**Scope of Changes:**
- 4 new files: admin_counselors.py (323 lines), audit_log.py (73 lines), test_admin_counselors.py (405 lines), migration (66 lines)
- 3 modified files: __init__.py (exports), main.py (router registration), story file (task checklist)
- Total: ~867 lines of new code + tests

### Code Quality Assessment

**Overall Grade: Excellent (A)**

The counselor management implementation demonstrates exceptional engineering quality with comprehensive audit logging, proper role-based authorization, and 100% test coverage. Backend implementation is production-ready with all 12 tests passing.

**Strengths:**
- âœ… **Clean Architecture:** Proper separation of concerns (models, routers, schemas, dependencies)
- âœ… **Comprehensive Audit Trail:** Every CUD operation logged with admin_id, IP address, timestamp, and change details
- âœ… **Granular Authorization:** SUPER_ADMIN and CONTENT_MANAGER can write, SYSTEM_MONITOR read-only
- âœ… **Test Coverage:** 100% endpoint coverage (12 tests) including authorization, audit logging, error cases
- âœ… **Error Handling:** Proper HTTP status codes (400, 401, 403, 404, 500) with clear error messages
- âœ… **Input Validation:** Pydantic schemas with field constraints (name max 100 chars, system_prompt max 5000 chars)
- âœ… **Database Design:** Proper indexes on audit_log (admin_user_id, timestamp, resource), CASCADE delete
- âœ… **Soft Delete Pattern:** DELETE endpoint sets enabled=false rather than hard delete (preserves data integrity)
- âœ… **Change Tracking:** UPDATE operations track old/new values in audit log details JSONB field
- âœ… **UUID Validation:** Invalid UUIDs return 400 with clear error message
- âœ… **Duplicate Prevention:** Unique name validation prevents duplicate categories
- âœ… **Type Safety:** Python type hints throughout, SQLAlchemy 2.0 Mapped columns

**Code Quality Details:**

**Models (audit_log.py):**
- Clean enum definition for AuditAction (CREATE, UPDATE, DELETE, LOGIN, LOGOUT)
- Proper foreign key with CASCADE delete maintains referential integrity
- JSONB details field allows flexible change tracking without schema changes
- IPv6-compatible ip_address field (String(45))
- Server-side defaults (gen_random_uuid(), CURRENT_TIMESTAMP) reduce application logic
- Proper indexes for common query patterns

**Router (admin_counselors.py):**
- Helper function `create_audit_log()` centralizes audit logic (DRY principle)
- Proper async/await patterns throughout
- Transaction management with commit/rollback on errors
- Consistent error handling with try/except blocks
- Change tracking in UPDATE truncates descriptions to 50 chars (prevents bloat in audit log)
- Proper use of dependency injection for authentication and database sessions

**Tests (test_admin_counselors.py):**
- 12 comprehensive tests covering all CRUD operations
- Authorization tests for all 3 roles (SUPER_ADMIN, CONTENT_MANAGER, SYSTEM_MONITOR)
- Audit log verification in create/update/delete tests
- Edge cases: duplicate names, invalid UUIDs, not found scenarios
- Proper async test fixtures with cleanup

**Migration (09b4cefa009d):**
- Proper enum creation with checkfirst=True (safe for re-runs)
- All indexes created explicitly
- Clean downgrade path

### Refactoring Performed

No refactoring performed. Code quality is already excellent and follows established patterns from Story 6.1.

### Compliance Check

- **Coding Standards:** âœ“ Clean, idiomatic Python with type hints and docstrings
- **Project Structure:** âœ“ Files correctly placed (app/routers, app/models, tests/routers, alembic/versions)
- **Testing Strategy:** âœ“ Comprehensive coverage at unit/integration level with async patterns
- **All ACs Met (Backend):** âœ“ ACs 1-4, 9 fully implemented and tested (frontend ACs 5-8, 10 pending)

### Requirements Traceability

**Backend Acceptance Criteria (Fully Covered):**

**AC 1: GET endpoint returns all categories including disabled (admins only)**
- **Given** an authenticated admin user (any role)
- **When** they request GET /api/admin/counselors/categories
- **Then** they receive all categories including disabled ones
- **Test Coverage:** test_get_all_categories_admin, test_system_monitor_read_only (GET portion)
- **Status:** âœ… PASS

**AC 2: POST endpoint creates new category with validation**
- **Given** an authenticated SUPER_ADMIN or CONTENT_MANAGER
- **When** they POST valid category data
- **Then** category is created and returned with 201 status
- **Validation:** Unique name, system_prompt max 5000 chars
- **Test Coverage:** test_create_category_success, test_create_category_duplicate_name
- **Status:** âœ… PASS

**AC 3: PUT endpoint updates existing category**
- **Given** an authenticated SUPER_ADMIN or CONTENT_MANAGER
- **When** they PUT update data with valid category_id
- **Then** category is updated and change details logged
- **Test Coverage:** test_update_category_success, test_update_category_not_found, test_update_category_invalid_uuid
- **Status:** âœ… PASS

**AC 4: DELETE endpoint soft deletes category (sets enabled=false)**
- **Given** an authenticated SUPER_ADMIN or CONTENT_MANAGER
- **When** they DELETE a category by ID
- **Then** category.enabled is set to false (soft delete)
- **Test Coverage:** test_disable_category_success, test_disable_category_not_found
- **Status:** âœ… PASS

**AC 9: Audit log entry created for every category modification**
- **Given** any CUD operation on categories
- **When** operation completes successfully
- **Then** audit log entry created with admin_user_id, action, resource details, IP address, timestamp
- **Test Coverage:** Verified in test_create_category_success, test_update_category_success, test_disable_category_success
- **Status:** âœ… PASS

**Frontend Acceptance Criteria (Pending Implementation):**

**AC 5:** Admin UI page at /admin/counselors - NOT YET IMPLEMENTED  
**AC 6:** Create/Edit modal form - NOT YET IMPLEMENTED  
**AC 7:** System prompt syntax highlighting - NOT YET IMPLEMENTED  
**AC 8:** Cache invalidation for student dashboard - NOT YET IMPLEMENTED  
**AC 10:** Success/error toast notifications - NOT YET IMPLEMENTED

### Coverage Gaps

**Frontend Not Implemented:**
- React page component (app/admin/counselors/page.tsx)
- CategoryFormModal component
- CRUD UI integration
- Toast notifications
- Cache invalidation strategy

**Missing Tests:**
- Frontend form validation tests
- UI interaction tests
- Manual testing checklist (17 items)

### Security Review

**Status: PASS_WITH_CONCERNS**

**Security Strengths:**
- âœ… **Authentication Required:** All endpoints require valid admin JWT token (401 for missing/invalid token)
- âœ… **Granular Authorization:** Role-based access control properly enforced (403 for insufficient permissions)
- âœ… **Audit Trail:** Comprehensive logging of all admin actions with IP address tracking
- âœ… **Input Validation:** Pydantic schemas prevent injection attacks, max length constraints
- âœ… **UUID Validation:** Invalid UUIDs rejected with 400 status (prevents path traversal)
- âœ… **Soft Delete:** Preserves data integrity and audit trail
- âœ… **No SQL Injection:** SQLAlchemy ORM with parameterized queries
- âœ… **Change Tracking:** Audit log captures what changed (old/new values)
- âœ… **IP Address Logging:** Tracks source IP for forensic analysis
- âœ… **Separation of Concerns:** Admin endpoints isolated from student endpoints

**Security Concerns Identified:**

**MEDIUM Severity - No Rate Limiting (SEC-003)**
- **Finding:** Admin counselor CRUD endpoints have no rate limiting protection
- **Risk:** Malicious admin or compromised account could spam create/update/delete operations
- **Impact:** Database bloat, audit log pollution, potential DoS
- **Suggested Action:** Add rate limiting middleware (recommend: 100 requests per 15 minutes per admin)
- **Mitigation:** Audit log provides forensic trail for abuse detection
- **Status:** Same issue as Story 6.1 (SEC-001) - acceptable for MVP, address before production
- **Note:** Less critical than login rate limiting since requires authenticated admin

**LOW Severity - No System Prompt Content Validation (SEC-004)**
- **Finding:** System prompts accepted without content validation (only length check)
- **Risk:** Admin could inject malicious prompts attempting prompt injection attacks
- **Impact:** LLM could behave unexpectedly if prompt contains injection attempts
- **Suggested Action:** Consider adding content validation (e.g., block attempts to override system instructions)
- **Mitigation:** Only trusted admins (SUPER_ADMIN, CONTENT_MANAGER) can modify prompts, audit log tracks changes
- **Status:** Low priority - trust model assumes admins are trustworthy
- **Note:** LLM providers have their own prompt injection defenses

**LOW Severity - Unbounded Audit Log Growth (SEC-005)**
- **Finding:** No retention policy or cleanup mechanism for audit_log table
- **Risk:** Audit log could grow indefinitely over time
- **Impact:** Disk space exhaustion, query performance degradation
- **Suggested Action:** Implement retention policy (Story 6.5 AC 8 mentions 1-year minimum)
- **Mitigation:** Indexes support efficient queries, PostgreSQL handles large tables well
- **Status:** Documented in Story 6.5, not blocking for this story

**Recommendations:**
1. **Rate Limiting (Medium Priority):** Add rate limiting to admin CRUD endpoints before production
2. **Retention Policy (Low Priority):** Implement in Story 6.5 as designed
3. **Prompt Content Validation (Optional):** Consider if prompt injection becomes a concern

### Performance Considerations

**Status: PASS**

**Performance Strengths:**
- âœ… **Async Operations:** All database operations use async/await for non-blocking I/O
- âœ… **Proper Indexes:** audit_log indexed on admin_user_id, timestamp, and (resource_type, resource_id)
- âœ… **Efficient Queries:** Simple SELECT queries with WHERE clauses use indexes
- âœ… **JSONB for Flexibility:** audit.details uses JSONB for efficient storage and querying
- âœ… **Pagination Ready:** Router supports pagination patterns (not yet implemented but architecture supports)
- âœ… **Minimal N+1 Queries:** Each endpoint uses single query for category lookup

**Performance Observations:**
- GET all categories returns all records (no pagination) - acceptable for MVP, likely < 20 categories
- UPDATE operation tracks changes in Python (not database-level triggers) - acceptable overhead
- Audit log writes add ~10-20ms per CUD operation - acceptable for admin operations

**Recommendations:**
- âœ“ Already using async patterns
- âœ“ Indexes properly placed
- Future: Add pagination to GET endpoint if category count grows > 100

### Testability Evaluation

**Status: EXCELLENT**

**Controllability:** âœ… Excellent
- Fixtures provide complete control over test data (admin users, categories)
- Dependency injection allows easy mocking of database sessions
- JWT token generation controlled via test fixtures

**Observability:** âœ… Excellent
- All operations return clear responses (201 Created, 200 OK, error messages)
- Audit log entries queryable for verification
- Database state directly inspectable via db_session fixtures

**Debuggability:** âœ… Excellent
- Clear error messages with appropriate status codes
- Test names clearly describe scenario being tested
- Async tests use proper pytest-asyncio patterns

### Technical Debt Identification

**Status: MINIMAL**

**Known Issues:**
1. **Windows Async Alembic Issue (Recurring):** Migration manually applied due to known Windows psycopg async driver issue (documented in Story 6.1). Not technical debt - known platform limitation with documented workaround.

2. **Frontend Not Implemented:** 40% of story (ACs 5-8, 10) pending frontend implementation. Not debt - expected workflow (backend-first).

3. **No Rate Limiting:** Same as Story 6.1 SEC-001 - documented, tracked, acceptable for MVP.

**Architectural Quality:**
- Clean separation of concerns
- Reusable patterns (create_audit_log helper)
- Consistent with Story 6.1 patterns
- No code duplication
- No outdated dependencies
- No architectural violations

### Files Modified During Review

**No files modified during review.** Code quality already excellent.

### Test Results

**Backend Tests: 12/12 PASSED (100%)**

```
tests/routers/test_admin_counselors.py::test_get_all_categories_admin PASSED
tests/routers/test_admin_counselors.py::test_get_categories_unauthorized PASSED
tests/routers/test_admin_counselors.py::test_create_category_success PASSED
tests/routers/test_admin_counselors.py::test_create_category_duplicate_name PASSED
tests/routers/test_admin_counselors.py::test_create_category_system_monitor_forbidden PASSED
tests/routers/test_admin_counselors.py::test_update_category_success PASSED
tests/routers/test_admin_counselors.py::test_update_category_not_found PASSED
tests/routers/test_admin_counselors.py::test_update_category_invalid_uuid PASSED
tests/routers/test_admin_counselors.py::test_disable_category_success PASSED
tests/routers/test_admin_counselors.py::test_disable_category_not_found PASSED
tests/routers/test_admin_counselors.py::test_content_manager_can_manage_categories PASSED
tests/routers/test_admin_counselors.py::test_system_monitor_read_only PASSED
```

**Test Execution Time:** 6.03 seconds  
**Warnings:** 33 deprecation warnings (httpx cookies, jose JWT, pydantic config) - non-blocking, same as Story 6.1

### Non-Functional Requirements Assessment

**Security:** âœ… PASS_WITH_CONCERNS
- Strong authentication and authorization implementation
- Comprehensive audit trail
- 3 issues identified: SEC-003 (medium - rate limiting), SEC-004 (low - prompt validation), SEC-005 (low - retention policy)
- Issues acceptable for MVP, documented for production

**Performance:** âœ… PASS
- Async operations throughout
- Proper database indexes
- Efficient queries
- Expected response times < 200ms for CRUD operations

**Reliability:** âœ… PASS
- Comprehensive error handling with try/except blocks
- Transaction management with rollback on errors
- Proper HTTP status codes for all scenarios
- Soft delete preserves data integrity

**Maintainability:** âœ… PASS
- Clean code structure with type hints
- Comprehensive docstrings
- DRY principle (create_audit_log helper)
- Well-organized test suite
- Follows Story 6.1 patterns (consistency)

**Scalability:** âœ… PASS
- Stateless endpoints scale horizontally
- Database indexes support high query loads
- JSONB allows flexible schema evolution
- Async patterns support high concurrency

**Usability:** âš ï¸ PENDING (Frontend Not Implemented)
- Backend provides clear error messages
- API design RESTful and intuitive
- Frontend UI/UX pending implementation

### Gate Status

**Gate:** PASS_WITH_CONCERNS â†’ [docs/qa/gates/6.2-counselor-management.yml](docs/qa/gates/6.2-counselor-management.yml)

**Quality Score:** 90/100
- Base: 100
- Medium issue (SEC-003 rate limiting): -10
- Backend-only implementation (40% pending): Not deducted (expected workflow)

**Issues Summary:**
- 1 medium severity (SEC-003: Rate limiting)
- 2 low severity (SEC-004: Prompt validation, SEC-005: Retention policy)
- Frontend implementation pending (expected)

**Decision Rationale:**
Backend implementation is production-quality with excellent test coverage (12/12 tests pass) and comprehensive audit logging. Same rate limiting concern as Story 6.1 (acceptable for MVP). Frontend implementation (40% of story) is expected next step, not a quality issue. Recommend completing frontend before marking story as Done.

### Recommended Status

**âœ“ Ready for Frontend Implementation**

**Backend Status:** Complete and production-ready (with rate limiting recommendation for final deployment)

**Next Steps:**
1. Implement frontend page at /admin/counselors (AC 5)
2. Build CategoryFormModal component (AC 6, 7)
3. Wire up CRUD operations with toast notifications (AC 10)
4. Handle cache invalidation (AC 8)
5. Complete manual testing checklist (17 items)
6. Update File List in story after frontend implementation
7. Re-review or mark Done after frontend completion

**Before Production Deployment:**
- Add rate limiting middleware to admin CRUD endpoints (same as Story 6.1 recommendation)
- Verify audit log retention policy implemented (Story 6.5)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-12-22 | 1.1 | Backend implementation complete, QA review | James (Dev), Quinn (QA) |
