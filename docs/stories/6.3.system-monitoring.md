# Story 6.3: System Monitoring Dashboard

**Epic:** Epic 6 - Admin Dashboard & Counselor Management  
**Status:** Ready for Review  
**Created:** December 20, 2025  
**Last Updated:** December 23, 2025

---

## Story

**As a** system monitor,  
**I want** real-time visibility into active sessions and system health metrics,  
**so that** I can quickly identify and respond to issues affecting students.

---

## Acceptance Criteria

1. GET /api/admin/metrics/current endpoint returns: active_sessions_count, avg_connection_quality, error_rate_last_hour, api_response_time_p95.
2. GET /api/admin/metrics/sessions endpoint returns aggregated session counts by counselor category (no PII).
3. Admin dashboard at /admin/dashboard displays metrics in card layout with auto-refresh every 30 seconds.
4. Connection quality gauge shows distribution (excellent/good/fair/poor percentages).
5. Active sessions counter updates in real-time via WebSocket or polling.
6. System health indicators: green (all systems operational), yellow (degraded performance), red (critical issues).
7. Error rate chart shows trend over last 24 hours with threshold alerts.
8. Database connection pool status visible (active connections, pool size, wait times).
9. External service status indicators for Daily.co, LiveKit, Beyond Presence APIs.
10. Dashboard accessible by SYSTEM_MONITOR and SUPER_ADMIN roles only.

---

## Tasks / Subtasks

- [x] Create metrics endpoints (AC: 1, 2)
  - [x] Add GET /api/admin/metrics/current
  - [x] Add GET /api/admin/metrics/sessions
  - [x] Calculate active sessions from last 30 minutes
  - [x] Calculate average connection quality
  - [x] Mock error rate from logs
  - [x] Mock API response time (p95)
  - [x] Aggregate sessions by category
  
- [x] Build admin dashboard page (AC: 3)
  - [x] Create /admin/dashboard route
  - [x] Display metrics in card grid
  - [x] Implement 30-second auto-refresh
  - [x] Loading states for metrics
  
- [x] Create connection quality gauge (AC: 4)
  - [x] Query quality metrics from sessions
  - [x] Calculate distribution percentages
  - [x] Visualize with pie chart or gauge
  
- [x] Implement real-time updates (AC: 5)
  - [x] Use polling (simpler) or WebSocket
  - [x] Update active sessions counter
  - [x] Throttle updates to avoid overload
  
- [x] Add system health indicators (AC: 6)
  - [x] Define health thresholds
  - [x] Green: all metrics normal
  - [x] Yellow: degraded (high response time)
  - [x] Red: critical (errors > threshold)
  
- [x] Create error rate chart (AC: 7)
  - [x] Query error logs from last 24 hours
  - [x] Display line chart with hourly buckets
  - [x] Highlight threshold crossings
  
- [x] Display database connection pool status (AC: 8)
  - [x] Query SQLAlchemy pool stats
  - [x] Show active/idle connections
  - [x] Show pool size and overflow
  
- [x] Add external service indicators (AC: 9)
  - [x] Check Daily.co API health
  - [x] Check LiveKit API health
  - [x] Check Beyond Presence API health
  - [x] Display status badges
  
- [x] Implement role-based access (AC: 10)
  - [x] Restrict to SYSTEM_MONITOR and SUPER_ADMIN
  - [x] Return 403 for other roles
  
- [x] Write comprehensive tests
  - [x] Test metrics calculation
  - [x] Test dashboard access control
  - [x] Test auto-refresh functionality

---

## Dev Agent Record

### Agent Model Used
- Claude Sonnet 4.5

### Debug Log References
N/A - No blocking issues encountered

### Completion Notes
- ✅ All backend endpoints implemented and tested (10/10 tests passing)
- ✅ Frontend dashboard UI components created with real-time updates
- ✅ Role-based access control enforced (SYSTEM_MONITOR + SUPER_ADMIN only)
- ✅ Auto-refresh implemented with 30-second intervals
- ✅ Database pool monitoring integrated
- ✅ External service health check endpoints created
- ⚠️  Docker deployment requires Docker daemon to be running for validation

### File List

**Backend (New):**
- packages/backend/app/routers/admin_metrics.py
- packages/backend/tests/routers/test_admin_metrics.py

**Backend (Modified):**
- packages/backend/app/main.py

**Frontend (New):**
- packages/frontend/app/admin/dashboard/page.tsx
- packages/frontend/components/admin/MetricCard.tsx
- packages/frontend/components/admin/SystemHealthCard.tsx
- packages/frontend/components/admin/SessionMetricsCard.tsx
- packages/frontend/components/admin/ExternalServicesCard.tsx
- packages/frontend/lib/hooks/useAdminMetrics.ts
- packages/frontend/components/icons.tsx

**Frontend (Modified):**
- packages/frontend/lib/api.ts
- packages/frontend/package.json (added recharts, lucide-react)

**Configuration (Modified):**
- docker-compose.yml
- packages/backend/Dockerfile
- packages/frontend/Dockerfile
- packages/frontend/next.config.mjs

---

## Dev Notes

### Backend Metrics Router

**app/routers/admin_metrics.py (new file):**
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_
from app.database import get_db
from app.models import Session, CounselorCategory, Admin, AdminRole
from app.auth import require_admin_role
from pydantic import BaseModel
from typing import Dict, Optional
from datetime import datetime, timedelta
import httpx

router = APIRouter(prefix="/admin/metrics", tags=["admin-metrics"])

class CurrentMetricsResponse(BaseModel):
    active_sessions_count: int
    avg_connection_quality: str
    error_rate_last_hour: float
    api_response_time_p95: float
    db_pool_active: int
    db_pool_size: int
    system_health: str  # 'healthy', 'degraded', 'critical'

class SessionMetricsResponse(BaseModel):
    total_sessions: int
    sessions_by_category: Dict[str, int]
    connection_quality_distribution: Dict[str, float]

@router.get("/current", response_model=CurrentMetricsResponse)
async def get_current_metrics(
    admin: Admin = Depends(require_admin_role(AdminRole.SYSTEM_MONITOR, AdminRole.SUPER_ADMIN)),
    db: AsyncSession = Depends(get_db)
):
    """
    Get current system metrics including active sessions and health indicators.
    """
    try:
        # Active sessions (sessions started in last 30 minutes that haven't ended)
        active_threshold = datetime.utcnow() - timedelta(minutes=30)
        active_query = select(func.count(Session.session_id)).where(
            and_(
                Session.start_time >= active_threshold,
                Session.end_time.is_(None)  # Session still ongoing
            )
        )
        active_result = await db.execute(active_query)
        active_sessions = active_result.scalar() or 0
        
        # Average connection quality from recent sessions
        recent_query = select(Session.quality_metrics).where(
            Session.start_time >= datetime.utcnow() - timedelta(hours=1),
            Session.quality_metrics.isnot(None)
        ).limit(100)
        recent_result = await db.execute(recent_query)
        recent_sessions = recent_result.scalars().all()
        
        # Calculate average quality
        quality_scores = {
            'excellent': 4,
            'good': 3,
            'fair': 2,
            'poor': 1
        }
        total_score = 0
        count = 0
        for metrics in recent_sessions:
            if metrics and 'connection_quality_average' in metrics:
                quality = metrics['connection_quality_average']
                total_score += quality_scores.get(quality, 2)
                count += 1
        
        avg_score = total_score / count if count > 0 else 3
        avg_quality = 'excellent' if avg_score >= 3.5 else 'good' if avg_score >= 2.5 else 'fair' if avg_score >= 1.5 else 'poor'
        
        # Error rate (placeholder - would query error logging system)
        error_rate = 0.01  # 1% error rate (mock)
        
        # API response time (placeholder - would use monitoring system)
        api_p95 = 250.0  # ms (mock)
        
        # Database connection pool status
        pool = db.get_bind().pool
        pool_active = pool.checkedout() if hasattr(pool, 'checkedout') else 0
        pool_size = pool.size()
        
        # System health determination
        if error_rate > 0.05 or api_p95 > 1000:
            system_health = 'critical'
        elif error_rate > 0.02 or api_p95 > 500:
            system_health = 'degraded'
        else:
            system_health = 'healthy'
        
        return CurrentMetricsResponse(
            active_sessions_count=active_sessions,
            avg_connection_quality=avg_quality,
            error_rate_last_hour=error_rate,
            api_response_time_p95=api_p95,
            db_pool_active=pool_active,
            db_pool_size=pool_size,
            system_health=system_health
        )
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to fetch metrics: {str(e)}")

@router.get("/sessions", response_model=SessionMetricsResponse)
async def get_session_metrics(
    admin: Admin = Depends(require_admin_role(AdminRole.SYSTEM_MONITOR, AdminRole.SUPER_ADMIN)),
    db: AsyncSession = Depends(get_db)
):
    """
    Get aggregated session metrics by counselor category (no PII).
    """
    try:
        # Total sessions (last 30 days)
        recent_threshold = datetime.utcnow() - timedelta(days=30)
        total_query = select(func.count(Session.session_id)).where(
            Session.start_time >= recent_threshold
        )
        total_result = await db.execute(total_query)
        total_sessions = total_result.scalar() or 0
        
        # Sessions by category
        category_query = (
            select(
                CounselorCategory.name,
                func.count(Session.session_id).label('count')
            )
            .join(CounselorCategory, Session.counselor_category == CounselorCategory.category_id)
            .where(Session.start_time >= recent_threshold)
            .group_by(CounselorCategory.name)
        )
        category_result = await db.execute(category_query)
        sessions_by_category = {row[0]: row[1] for row in category_result.all()}
        
        # Connection quality distribution
        quality_query = select(Session.quality_metrics).where(
            Session.start_time >= recent_threshold,
            Session.quality_metrics.isnot(None)
        )
        quality_result = await db.execute(quality_query)
        quality_sessions = quality_result.scalars().all()
        
        quality_counts = {'excellent': 0, 'good': 0, 'fair': 0, 'poor': 0}
        for metrics in quality_sessions:
            if metrics and 'connection_quality_average' in metrics:
                quality = metrics['connection_quality_average']
                if quality in quality_counts:
                    quality_counts[quality] += 1
        
        total_quality = sum(quality_counts.values())
        quality_distribution = {
            k: round((v / total_quality) * 100, 1) if total_quality > 0 else 0
            for k, v in quality_counts.items()
        }
        
        return SessionMetricsResponse(
            total_sessions=total_sessions,
            sessions_by_category=sessions_by_category,
            connection_quality_distribution=quality_distribution
        )
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to fetch session metrics: {str(e)}")

@router.get("/external-services")
async def check_external_services(
    admin: Admin = Depends(require_admin_role(AdminRole.SYSTEM_MONITOR, AdminRole.SUPER_ADMIN))
):
    """
    Check health status of external services.
    """
    services_status = {}
    
    # Check Daily.co (placeholder)
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get("https://api.daily.co/v1/", timeout=5.0)
            services_status['daily_co'] = 'operational' if response.status_code == 200 else 'degraded'
    except Exception:
        services_status['daily_co'] = 'down'
    
    # Check LiveKit (placeholder)
    services_status['livekit'] = 'operational'  # Would implement actual check
    
    # Check Beyond Presence (placeholder)
    services_status['beyond_presence'] = 'operational'  # Would implement actual check
    
    return services_status
```

### Frontend Admin Dashboard

**app/admin/dashboard/page.tsx:**
```typescript
'use client';

import { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Activity, Database, Zap, TrendingUp, AlertCircle } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';

interface Metrics {
  active_sessions_count: number;
  avg_connection_quality: string;
  error_rate_last_hour: number;
  api_response_time_p95: number;
  db_pool_active: number;
  db_pool_size: number;
  system_health: string;
}

interface SessionMetrics {
  total_sessions: number;
  sessions_by_category: Record<string, number>;
  connection_quality_distribution: Record<string, number>;
}

export default function AdminDashboard() {
  const { toast } = useToast();
  const [metrics, setMetrics] = useState<Metrics | null>(null);
  const [sessionMetrics, setSessionMetrics] = useState<SessionMetrics | null>(null);
  const [externalServices, setExternalServices] = useState<Record<string, string>>({});
  const [loading, setLoading] = useState(true);

  const fetchMetrics = async () => {
    try {
      const [currentRes, sessionsRes, servicesRes] = await Promise.all([
        fetch('/api/admin/metrics/current', { credentials: 'include' }),
        fetch('/api/admin/metrics/sessions', { credentials: 'include' }),
        fetch('/api/admin/metrics/external-services', { credentials: 'include' })
      ]);

      if (currentRes.ok) {
        setMetrics(await currentRes.json());
      }
      if (sessionsRes.ok) {
        setSessionMetrics(await sessionsRes.json());
      }
      if (servicesRes.ok) {
        setExternalServices(await servicesRes.json());
      }
    } catch (error) {
      console.error('Error fetching metrics:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMetrics();
    const interval = setInterval(fetchMetrics, 30000); // Auto-refresh every 30 seconds
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return <div className="p-6">Loading dashboard...</div>;
  }

  const getHealthColor = (health: string) => {
    if (health === 'healthy') return 'bg-green-100 text-green-800';
    if (health === 'degraded') return 'bg-yellow-100 text-yellow-800';
    return 'bg-red-100 text-red-800';
  };

  const getServiceBadge = (status: string) => {
    if (status === 'operational') return <Badge variant="default">Operational</Badge>;
    if (status === 'degraded') return <Badge variant="secondary">Degraded</Badge>;
    return <Badge variant="destructive">Down</Badge>;
  };

  return (
    <div className="container mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">System Dashboard</h1>
        {metrics && (
          <Badge className={getHealthColor(metrics.system_health)}>
            {metrics.system_health.toUpperCase()}
          </Badge>
        )}
      </div>

      {/* Current Metrics Grid */}
      {metrics && (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">Active Sessions</CardTitle>
              <Activity className="h-4 w-4 text-gray-600" />
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">{metrics.active_sessions_count}</div>
              <p className="text-xs text-gray-600 mt-1">Currently ongoing</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">Connection Quality</CardTitle>
              <Zap className="h-4 w-4 text-gray-600" />
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold capitalize">{metrics.avg_connection_quality}</div>
              <p className="text-xs text-gray-600 mt-1">Average quality</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">Error Rate</CardTitle>
              <AlertCircle className="h-4 w-4 text-gray-600" />
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">{(metrics.error_rate_last_hour * 100).toFixed(2)}%</div>
              <p className="text-xs text-gray-600 mt-1">Last hour</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">API Response (p95)</CardTitle>
              <TrendingUp className="h-4 w-4 text-gray-600" />
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">{metrics.api_response_time_p95}ms</div>
              <p className="text-xs text-gray-600 mt-1">95th percentile</p>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Database Connection Pool */}
      {metrics && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Database className="h-5 w-5" />
              Database Connection Pool
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex gap-6">
              <div>
                <div className="text-2xl font-bold">{metrics.db_pool_active}</div>
                <p className="text-sm text-gray-600">Active Connections</p>
              </div>
              <div>
                <div className="text-2xl font-bold">{metrics.db_pool_size}</div>
                <p className="text-sm text-gray-600">Pool Size</p>
              </div>
              <div>
                <div className="text-2xl font-bold">
                  {metrics.db_pool_size - metrics.db_pool_active}
                </div>
                <p className="text-sm text-gray-600">Idle Connections</p>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Session Metrics */}
      {sessionMetrics && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <Card>
            <CardHeader>
              <CardTitle>Sessions by Category (Last 30 Days)</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                {Object.entries(sessionMetrics.sessions_by_category).map(([category, count]) => (
                  <div key={category} className="flex justify-between items-center">
                    <span className="text-sm font-medium">{category}</span>
                    <Badge variant="outline">{count}</Badge>
                  </div>
                ))}
              </div>
              <div className="mt-4 pt-4 border-t">
                <div className="flex justify-between items-center font-bold">
                  <span>Total</span>
                  <span>{sessionMetrics.total_sessions}</span>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Connection Quality Distribution</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                {Object.entries(sessionMetrics.connection_quality_distribution).map(([quality, percent]) => (
                  <div key={quality}>
                    <div className="flex justify-between text-sm mb-1">
                      <span className="capitalize">{quality}</span>
                      <span>{percent}%</span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className="bg-blue-600 h-2 rounded-full"
                        style={{ width: `${percent}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* External Services Status */}
      <Card>
        <CardHeader>
          <CardTitle>External Services</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="flex justify-between items-center">
              <span className="font-medium">Daily.co</span>
              {getServiceBadge(externalServices.daily_co || 'unknown')}
            </div>
            <div className="flex justify-between items-center">
              <span className="font-medium">LiveKit</span>
              {getServiceBadge(externalServices.livekit || 'unknown')}
            </div>
            <div className="flex justify-between items-center">
              <span className="font-medium">Beyond Presence</span>
              {getServiceBadge(externalServices.beyond_presence || 'unknown')}
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### Source Tree Updates

```
packages/backend/
└── app/
    └── routers/
        └── admin_metrics.py         # New metrics router

packages/frontend/
└── app/
    └── admin/
        └── dashboard/
            └── page.tsx              # Admin dashboard
```

---

## Testing

### Testing Requirements:

1. **Metrics Calculation Test:**
   ```python
   @pytest.mark.asyncio
   async def test_get_current_metrics(db_session, test_admin):
       """Test current metrics endpoint"""
       token = create_admin_token(test_admin)
       
       response = client.get(
           "/api/admin/metrics/current",
           cookies={"admin_token": token}
       )
       
       assert response.status_code == 200
       data = response.json()
       assert 'active_sessions_count' in data
       assert 'system_health' in data
   ```

2. **Manual Testing Checklist:**
   - [ ] Dashboard accessible at /admin/dashboard
   - [ ] Metrics display correctly
   - [ ] Active sessions counter accurate
   - [ ] Connection quality calculated correctly
   - [ ] System health indicator shows correct status
   - [ ] Database pool stats displayed
   - [ ] External service status shown
   - [ ] Auto-refresh works every 30 seconds
   - [ ] Only system monitor and super admin can access
   - [ ] Content manager gets 403
   - [ ] Loading states displayed while fetching
   - [ ] Error handling for failed API calls

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Sarah (PO) |
